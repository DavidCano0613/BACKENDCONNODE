# CREACON DE UN BACKEND CON NODE JS
## PASOS PARA CREAR UN BACKEND
1. Elegir la arquitectura de software m谩s adecuada para el caso.
2. Configurar del entorno de desarrollo y de producci贸n con buenas practicas.
3. Instalar las librerias que seran necesarias para el desarrollo del proyecto.
4. Creaci贸n del servidor con EXPRESS.JS
5. Separar responsabilidades como lo indique la arquitectura elegida
6. Crear la capa de routing.
7. Crear la capa de middlewares.
8. Crear la capa de servicios.
9. Crear la capa de librerias y establecer la conexi贸n con bases de datos.
10. Crear la capa de seguridad, establecer todo lo relacionado con autenticaci贸n y autorizaci贸n.
11. Crear y correr de pruebas.
12. Hacer deploy.
---

# 1) The Clean Architecture.
Es un estilo de arquitectura de software que funciona separando el software en capas.

> La capa mas peque帽a es la de entidades en esta capa es donde se definen las entidades base del negocio en este proyecto por ejemplo, usuarios, productos, ordenes de compra, categorias etc...

> Luego se tiene una capa de casos de uso, aqui normalmente se tiene todo lo relacionado a la l贸gica de negocio y se ven los servicios en esta capa.

> Luego estan los controladores que son los que brindan acceso a estos servicios, aqu铆 se ve el routing y los middlewares que ayudan a capturar errores y a hacer validaciones.

Imagen:
![](./assets/theclena.png)

De una forma m谩s transparente:
![](./assets/Captura%20de%20pantalla%202022-07-31%20140441.png)

> Finalmente esta la capa de los clientes que seran todos los dispositivos conectados a esa API.

> Resumen del flujo: Los clientes se conectan con los controladores, estos a su vez se conectan con los servicios y los servicios se encargan de conectarse con las bases de datos o su respectiva fuente de informaci贸n y realizar una l贸gica de negocio.

![](./assets/Captura%20de%20pantalla%202022-07-31%20170216.png)


---
# 2) Configuraci贸n de entorno de etorno de desarrollo y de producci贸n con buenas practicas:

Establecer una buena configuraci贸n servira para trabajar de una forma m谩s apropiada.

- Crear un buen **git ignore:** Este se coloca en el directorio raiz del proyecto:  https://www.toptal.com/developers/gitignore.
- Configuraci贸n del editor de c贸digo: Es recomendable para que todos los desarrolladores tengan la misma configuraci贸n en su editor de c贸digo. **Tener la extensi贸n editorconfig**. Se puede establecer una configuraci贸n que lo que haga sea formatear el editor de c贸digo para que todos trabajen de la misma manera.
- Nodemon como servidor de desarrollo: Creaaci贸n algunas tareas o scripts en el package json.
- Linters: Eslint
- Pipelines:

### Instalaci贸n de paquetes:
npm i nodemon eslint eslint-config-prettier eslint-plugin-prettier prettier -D

---
# Instalaci贸n de la librerias que seran necesarias para el desarrollo

A continuaci贸n se presenta un paquete de librerias que pueden ser utiles para crear backend con node js:

1. Express: npm i express

2. Eslint:

3. nanoid

4.

2. Boom: npm i @hapi/boom

3. Joi:
npm install --save joi
npm install --save-dev @types/joi

4. Postgres:
* npm install --save pg pg-hstore
* npm install --save mysql2
* npm install --save sqlite3
* npm install --save tedious // MSSQL

5. Cors: npm i cors

6. sequelize:
* npm install --save sequelize
* npm i sequelize-cli -D: Para migraciones
*

npm i dotenv

---
# Creaci贸n del servidor con express JS

EXPRESS: Es una libreria que permite gestionar de una mejor manera un servidor web.

La instacia de express trae en forma de funci贸n los m茅todos/verbos http.
**get post put patch y delete**.

A estas funciones se les puede pasar los paths (_URLS,Endpoints_) que no son m谩s que un punto final en el servidor donde se aloja un recurso. Los clientes van a solicitar recursos a esas URLS con los verbos http y va haber un handler que se ejecuta cuando la ruta coincide. Esto se puede entender de la siguiente forma:

>El m茅todo http recibe dos parametros la URL y una funci贸n de tipo callback llamada handler que ejecuta cierta l贸gica de programaci贸n CUANDO se ataque a ese EAndpoint. El callback recibe dos objetos que son *REQUEST AND RESPONSE*.

Los objetos **request y response** son muy importante puesto que por medio de estos es que se recibe y envia la informaci贸n.

Express permite trabajar con el REQUEST.BODY de una forma m谩s amigable.
Express contiene algo llamado *parser* el cual es un middleware que ayuda a tomar el body que viene en forma de un stream y _parsearlo_ a algun tipo de dato, ya sea un archivo de texto, un json o lo que sea. Lo m谩s usual es parsearlo a JSON. Este se puede establecer en el index de forma global para que a todos los endpoints les llegue el body parseado.

---
# Separaci贸n de responsabilidades (Single Responsability Principle)

Hace parte de los principios SOLID. En este caso *Single Responsability Principle* establece que es una mala practica tener c贸digo que hace de todo, es decir si una funci贸n tiene como nombre sumar, no deber铆a en su cuerpo estar calculando integrales. Esto se puede llevar al plano de los archivos, routing, clases, modulos, servicios y m谩s. Es aqui donde se lleva realmente acabo la arquitectura.

---
# Creaci贸n de la capa de routing y controladores

* Como se menciono the clean architecture establece que el routing hace parte **de la capa de acceso a los servicios** y tambi茅n se encarga de proporcionar los EndPoints a los cuales los clientes se van a conectar para acceder a los recursos. Sin embargo, es una pesima practica definir todo el routing en el archivo index donde se levanta el servidor.
* Express cuenta con sistema de enrrutamiento el cual permite separar las rutas.
* Los Routers en express son middlewares que permiten agrupar rutas para as铆 separar la l贸gica de los endpoints.
* Todo el routing deberia dividirse en archivos que se encarguen de definir las rutas de cada endpoint en espesifico.
* Lo ideal es crear una carpeta que contenga todo el routing.
* El nombre que se le dan a estos archivos dependen del equipo de desarrollo.
* Se debe definir un path principal para ese router, es decir debe tener como su entorno propio.
---
# Creaci贸n de los middlewares

## Que son los middlewares y para que sirven
Como se ha observado anteriormente en los Endpoints se establece cierta l贸gica. Pero 驴que tal si se necesita ejecutar una funci贸n antes de que se ejecute la l贸gica del endpoint, como por ejemplo, validar permisos o validar que la data venga como se espera?

Los middlewares sirven para eso, pues son FUNCIONES que se ejecutan de **FORMA PREVIA** a los handlers de los endpoints, es muy importante hacer esta notaci贸n y es que antes de que la petici贸n llegue al endpoint y se ejecute la l贸gica que tiene el handler asociado a este, se ejecuta primero el middleware que esta definido en esa ruta.

## Sintaxis
> Se crea una funci贸n normal con la logica que va contener ese middleware, luego ya sea a nivel de toda la app o de un grupo de endpoints espesificos se llama al m茅todo USE.

> Express dispone del **m茅todo use()** el cual recibe como parametro el **request y el response** y un m茅todo muy importante llamado **next** el cual se explica despues de las propidades de los middlewares. Entonces en ese orden de ideas los middlewares se crean asi:
- algo.use()

## Propiedades de los middlewares en express JS

1. **El orden es importante:** Los middlewares se ejecutan en el mismo orden que se llamen en el c贸digo

2. **Pueden ser utilizados de forma global:** Ejemplo: para capturar errores a nivel general en toda la aplicaci贸n, en este caso pueden ponerse en el index de la app.

3. **Pueden ser utilizados a nivel de cada endpoint o de un grupo de endpoints:** De esta forma el middleware una vez se ejecuta, llama al handler del endpoint al que se haya atacado. Esto tambi茅n lo hace next()

4. **Funcionan de forma secuencial** Una de sus propiedades es que pueden funcionar de forma secuencial. Cada middleware puede tener una funci贸n  espesifica, una vez termine... sigue el otro middleware con otra l贸gica diferente. Es como tener funciones tradicionales conectadas en cadena, se ejecuta una y le pasa el flujo a la siguiente y asi sucesivamente. Un middleware puede bloquear el flujo, Es decir si cierta l贸gica no se cumple no se permite seguir con el siguiente middleware o no permite acceder a la siguiente capa, esto viene muy bien a la hora de hacer validaciones.

5. **El dichoso m茅todo Next():** El m茅todo NEXT (que tambi茅n viene como par谩metro en el use()) es un callback que permite que el siga el proximo middleware o en su defecto el handler que tenga el endpoint. **(Hay un dilema y es que express no diferencia muy bien entre middlewares y rutas, practicamente las funciones (handlers) que se ejecutan en las rutas son middlewares tambi茅n)**.
## Uses Cases
- Funcionan como pipes
- Validan datos
- Capturan errores
- Validan permisos
- Controlan accesos

## Middleware de tipo error.
Es ideal que antes de que la petici贸n llegue al endpoint se capturen los posibles errores. Sin embargo, estos no deben devolverse a secas. Los errores hay que gestionarlos, darles un formato y mandarlos de una forma clara y bien presentada al cliente.

### Sintaxis middleware de error
Tienen el par谩metro error de primero **(error,req,res,next).**

Son utiles para crear un middleware GLOBAL (funcionan a nivel de todos los endpoints) que acompa帽e a todas las peticiones de tal manera de que si sale un error este se capture y se le de un formato para retornalo, **驴que formato?** ejemplo: _el tipo de error, el codigo de estado y un mensaje._.

Este tipo de middlewares se deben crear despues de hacer todo el Routing.
Este tipo de middlewares se crean en un carpeta y se llaman donde se requiran y se ponen tambi茅n en el routing.

## Libreria Boom
Esta libreria ayuda a gestionar de forma m谩s eficiente lo errores. Pues hasta el momento se ha enviado el status code, message, entre otros de forma que siempre se debe poner el status code manualmente. Boom ayuda a ahorrar esta molestia.

isBoom: Si es un error de tipo boom
output: Toda la informacion del error

#### Ventajas de usar Boom:
- Ayuda a no tener que poner el status code de forma manual
- Gestiona mejor los errores


## Middleware de tipo validaci贸n
Otro uso muy com煤n de los middlewares es validar los datos que vienen desde el cliente (front-end). Para esto existe una librer铆a llamada Joi.

Como backend un desarrollador deber铆a asgurarse de que lo que le envia el front-end cumple con la integridad de datos, que un precio este un formato adecuado o por ejemplo que se envien los atributos que se esperan, con los middlewares se pueden capturar este tipo de errores antes de que lleguen a la capa de servicios.


---
# Creaci贸n de la capa de servicios

Es la capa donde se pone la l贸gica del negocio como tal. Esta capa encapsula todos los casos de uso.

Los servicios tienen la l贸gica del negocio y obtienen informaci贸n por medio de librerias a una base de datos o de una api externa. Luego estos servicios pueden sen consumidos por los controladores. Practicamente en esta capa se centraliza la l贸gica de la aplicaci贸n. Pero esta capa es accedida una vez se ha cumplido con todo lo que los controladores y middlewares tienen que hacer, ya sea: Capturar errores, hacer validaciones, verificar autenticaci贸n y autorizaci贸n.
---
# VARIABLES DE AMBIENTE / ENTORNO
Tener archivos de configuraciones separados en diferentes ambientes es una buena practica. Cuando una aplicaci贸n web se va a a desplegar se esta hablando de que una aplicaci贸n se va usar al menos en dos ambientes diferentes. _Producci贸n y desarrollo_.

En las empresas grandes existen m谩s entornos.

Para cuyos casos es necesario para cada entorno crear sus respectivos archivos de configuraci贸n.

Las variables de entorno son variables dinamicas que afectan a el comportamiento de una aplicaci贸n y son usadas cuando una aplicaci贸n corre en diferentes entornos, por ejemplo, el de desarrollo o el de producci贸n.

## USOS MS COMUNES:
1. Almacenar informaci贸n sensible.
2. Para aplicar configuraciones que sean espesificas para entornos de desarrollo.
3. Para despliegue.

### Cuando se crean aplicaciones con Node JS del lado del back-end es muy usual conectarse a servicios de terceros, ejemplos:

* Bases de datos: Cuando se establece una conexi贸n a una base de datos desde un back-end se debe ingresar la informaci贸n necesaria para hacer de forma exitosa dicha conexi贸n, informaci贸n como el usuario de la base de datos, la contrase帽a, el host, el puerto entre otros.

* APIS de terceros: Estos servicios brindan un token y client_id que sirven para conectarse a estos servicios.

## Formas de crear las conexiones con bases de datos.
> Tipeando de forma directa: Una forma de hacer estas conexiones es tipeando de forma explicita en el c贸digo, en otras palabras quemando los datos, todos esos datos LOS CUALES POR SUPUESTO **SON MUY SENSIBLES** y por lo tanto es una **pesima** practica hacerlo de esta forma. Al publicar esto en un repositorio todo el mundo tiene acceso a esa informaci贸n y podran acceder a la base de datos.

> Usando variables de entorno: Estas le a帽aden una capa de seguridad al c贸digo dado que ya no muestra los datos de forma quemada.

## Uso de variables de entorno en Node JS

### Objeto process.env:
process.env es un objeto **GLOBAL** que contiene como propiedades todas las variables de entorno.

Se puede crear un objeto config que contenga todas las variables de etorno. Una practica que suele seguirse es protegerlas un poco y guardar todas estas variables de entorno en una URL con todo el esquema de conexi贸n.

Para acceder al archivo .env y cargar las variables a un proceso de node, se debe instalar un paquete para poder acceder a estas y se llama al m茅todo config.

Es un archivo que va contener todas las variables de entorno:
- Instalar el modulo dotenv
- Crear la carpeta config
- Crear el archivo .env
- Crear el archivo .env.example
- **No se debe subir el repositorio el .env**
- **Se pone en el repositorio el .env.example**
- Todas se escriben en UPPERCASE
- Si hay varias palabras se separan por _
- Creaci贸n de de las variables de entorno
- Crear el script

### Archivo .env y .env.example
Se deben separar debido a que en el .env existe informaci贸n sensible. Sin embargo, es necesario mostrar cuales son esas variables de etorno, por lo tanto, en el .env.example se ponen como un ejemplo de cuales son sin ponerlas de forma explicita.

---
# CAPA DE librerias
Estan se encargan de todo lo que tiene que ver con conexi贸n con terceros, es en esta carpeta donde se crean todos los archivos que se encargan de conectar a la back-end con terceros como **Bases de datos** y **APIS**

# CONEXIN A BASE DE DATOS
Existen diversas formas de conectar el **Backend** con **bases de datos**.

1. La m谩s com煤n, por lo menos para empezar a entender el como gestionar informaci贸n de una base de datos desde el backend es descargando un SGDB y buscando la libreria que permita conectar a Node js con dicho motor. Sin embargo, la forma recomendada es con un pooling.

> Conexi贸n con POSTGRESQL: Para conectar Node JS con una base de datos pg: https://node-postgres.com/
> Conexi贸n con MYSQL: Para conectar Node JS con una base de datos mysql: https://node-postgres.com/
> Conexi贸n con SQLSERVER: Para conectar Node JS con una base de datos sqlserver: https://node-postgres.com/

## Pooling
Cuando se trabaja con bases de datos en el backend, cada vez que se hace una operaci贸n contra la misma, primero se debe generar una conexi贸n con la base de datos.

Por lo que tener que llamar al m茅todo que conecta la base de datos con el backend por cada vez que se quiere hacer una operaci贸n se vuelve muy tedioso. Ademas, eso esta mal porque puede sobrecargar el servidor de request. Entonces, esto es un problema porque por cada request se crea una negociacion con la base de datos, se tarda 20ms o mas, y asi se va saturando el servidor. Por lo tanto el SGDB proporcionan una interfaz llamada pool.

Un pool de conexiones basicamente es un conjunto limitado de conexiones a una base de datos, que es manejado por un servidor de aplicaciones de forma tal, que dichas conexiones pueden ser reutilizadas por los diferentes usuarios.

Es como un lugar en el que se centralizan estas conexiones para no tenerlas que estar llamando cada vez, si no desde el pool. Lo que hace el pool es sencillamente es ser un mediador entre las bases de datos y el cliente.

Entonces a medida que los clientes empiecen a hacer consultas, la aplicacion de manera asincrona se conectara con el pool y el pool se encargara tanto de abrir o cerrar conexiones para que la informacion siga trabajando de manera eficiente.

![](./assets/OOFTe.png)


---
# ORM: Object-Relational mapping
Un ORM es un modelo de programaci贸n es una capa que permite mapear las estructuras de una base de datos relacional en entidades de la programaci贸n orientada a objetos. Es decir, el ORM toma las tablas y las convierte en POO basicamente. Es como usar programaci贸n orientada a objetos para hacer operaciones contra la base de datos. El ORM es agnostico, pues este se puede usar en cualquier SGDB.

Al abstraer este tipo de programaci贸n, se delega su implementaci贸n al Backend, es decir, le a帽adimos una de responsabilidad a la capa transaccional del servidor:

Los beneficios son los siguientes:

Acciones como CRUD (Create, Read, Update, Delete) son administradas mediante ORM.
La implementaci贸n de seeds o semillas, nos permiten recuperar, mediante c贸digo, la estructura de una BD.

## EL DAO Y DTO
Una de las bases te贸ricas para entender este modelo es mediante el conocimiento del DAO (Data Access Object) y DTO (Data Transfer Object), los cuales nos permiten desestructurar un ORM en m贸dulos de abstracci贸n para **acceder a la DB** y **transferir datos desde la misma DB**, respectivamente hablando.

Los contras ser铆an:
- Delegaci贸n de responsabilidades al server.
- Descentralizaci贸n de trabajo, directa, de una Data Base.

## SEQUELIZE
* npm install --save sequelize
## Instalar segun la base de datos a utilizar:
* npm install --save pg pg-hstore
* npm install --save mysql2
* npm install --save sqlite3
* npm install --save tedious / MSSQL

## Caracteristicas de Sequelize
Sequelize gestiona la conexi贸n con la base de datos.

## Instalaci贸n y configuraci贸n
Lo primero que estamos haciendo es importar la clase Sequelize despues lo que se hace es crear una nueva instancia de esta clase que recibe como par谩metros en su constructor, el nombre de la base de datos, el nombre del usuario, la contrase帽a, y un objeto de configuraci贸n donde especificamos el host de nuestra base de datos, el dialect que es donde ponemos que base de datos se esta utilizando.

Sequelize permite utilizar consultas de forma directa con sql:

## Modelos en sequelize

Los modelos en sequelize nos permiten representar las tablas y manipular estos datos, un modelo se define de la siguiente manera:

Usando la clase class model Extends Model.
Usando el m茅todo sequelize.define()
Consultar los tipos de datos y configuraciones de columnas que admite sequelize.
Por defecto el nombre que se le de al modelo se crea en la base de datos
Se puede crear explicitamente el nombre de la tabla aunque el modelo tenga otro nombre

### Create Update and Delete
### Sincronizaci贸n de Modelos.

Aqu铆 es donde entra en juego la sincronizaci贸n de modelos. Un modelo se puede sincronizar con la base de datos llamando a model.sync(options), una funci贸n as铆ncrona (que devuelve una Promesa). Con esta llamada, Sequelize realizar谩 autom谩ticamente una consulta SQL a la base de datos. Tenga en cuenta que esto cambia solo la tabla en la base de datos, no el modelo en el lado de JavaScript.

>User.sync()- Esto crea la tabla si no existe (y no hace nada si ya existe)
>User.sync({ force: true })- Esto crea la tabla, borrandola primero si ya exist铆a
>User.sync({ alter: true })- Esto verifica cu谩l es el estado actual de la tabla en la base de datos (qu茅 columnas tiene, cu谩les son sus tipos de datos, etc.), y luego realiza los cambios necesarios en la tabla para que coincida con el modelo.

>Se puede hacer a nivel de un solo modelo Model.sync()

>Se puede hacer a nivel generl todos los modelos existentes sequelize.sync

## Consultas
Para hacer consultas con Sequelize
Se puede mapear con POO o se le puede mandar una consulta directa tipo SQL, la informaci贸n la devuelve en un array, con dos posiciones la primera es la data como tal y la otra es meta data que viene a ser como informac铆on adicional de la consulta.

## Cambio de base de datos

## Migraciones
Cuando una aplicaci贸n esta en producci贸n esta el dilema de como se sincroniza la base de datos con lo que se va haciendo en local ?

El problema de sequelize.sync() es que empieza a leer los modelos, crea tablas y hace relist (se sobrescribe informaci贸n), no se aconseja que se corra esto as铆 en producci贸n. Es mejor sincronizar con un sistema de migraciones.

Las migraciones son como un sistema de control de versiones para bases de datos.

Mantienen un hisotrial del esquema que se va manteniendo en la base de datos.

Usualmente se va tener una primer migracic贸n que es la que crea toda la estructura inicial y todas las tabals como lass columnas con sus respectivos tipos de datos. Luego a medida que se van a帽adiendo campos o haciendo alguna modificacion deberiamos tener esto en un sistema de migraciones, 驴Porque? esto es debido a que cuando un sistema esta corriendo en producci贸n, se debe replicar todo y con las migraciones se pueden enviar nuevos **releases**. El sistema en producci贸n debe saber en que momento de la migraci贸n para que no se rescriban datos ni repita informaci贸n.

Nuevamente la funci贸n sync crea nuevamente tablas y dem谩s lo cual es muy peligroso para
cuando el sistema esta en producci贸n dado que se puede sobrecargar al estar creando tablas una y otra vez cuando se lanza un nuevo feature, e incluso puede haber pedida de informaci贸n.

La migraci贸n corre o toma como punto de referencia la ultima que se haya corrido.

## 驴COMO CREAR MIGRACIONES EN SEQUELIZE?

Se instala npm i sequelize-cli -D

>Agregar un archivo de configuraci贸n en la carpeta raiz llamado -sequelizerc

>Las migraciones van a tener su propia conex铆on independiente a la que ya tiene la aplicaci贸n

>Se deben declarar los ambientes de development y production

> A diferencia de laravel que trae los comandos de terminal por defecto, en sequelize debemos crearlos y la forma de hacerlo es creando scripts de NPM.

## Seeders
### UP:
### DOWN:
### Comandos de migraciones

* sequelize-cli db:migrate: Run pending migrations.
* sequelize-cli db:migrate:schema: timestamps:add Update migration table to have timestamps.
* sequelize-cli db:migrate:schema: timestamps:add Update migration table to have timestamps
* sequelize-cli db:migrate:status: List the status of all migrations
* sequelize-cli db:migrate:undo: Reverts a migration
* sequelize-cli db:migrate:undo: all Revert all migrations ran

* sequelize-cli db:seed: Run specified seeder
* sequelize-cli db:seed:undo: Deletes data from the database
* sequelize-cli db:seed:all: Run every seeder
* sequelize-cli db:seed:undo:all: Deletes data from the database

* sequelize-cli db:create Create database specified by configuration
* sequelize-cli db:drop Drop database specified by configuration
* sequelize-cli init Initializes project
* sequelize-cli init:config Initializes configuration
* sequelize-cli init:migrations Initializes migrations
* sequelize-cli init:models Initializes models
* sequelize-cli init:seeders Initializes seeders
* sequelize-cli migration:generate Generates a new migration file
[aliases: migration:create]
* sequelize-cli model:generate Generates a model and its migration
[aliases: model:create]
* sequelize-cli seed: generate Generates a new seed file.
* generate create-user
---

Cuando se corre el comanndo run esot genera una tabla llamada SequelizeMeta esta tabla es clave, esto es lo que se permite que se haga el tracking (historico) de la migraci贸n, es como un registro o historial por lo cual si se vuelve a correr la migraci贸n ya no va a rescirbir informaci贸n porque ya tiene registro de que esa migraci贸n se hizo eso permite tener un orden a la hora de mandar cambios a producci贸n

Para hacer modificaciones a tablas ya creadas se tiene que ir al modelo se hace el camibio pertinente y se informa de esto a la migraci贸n.


## Relaciones en sequelize

One to one relation
One to many
Many to Many


https://pigexception.wordpress.com/2016/03/26/patron-de-diseno-dao/


---
# Considereaciones para hacer deploy

1. Evaluar los Cors
2. Que la api este en un servidor https
3. Correr todos los procesos de build (typescript o sass por ejemplo)
4. Remover todos los console.log
5. Seguridad (helmet)
6. Testing

# CORS
Uno de los problemas m谩s comunes es el problema de cors, es un problema muy com煤n a la hora de conectar el **Back-end con el Front-end**.

### Cross.Origin Resource Sharing
Significa que los servidores tienen una protecci贸n por defecto y es que solo aceptan peticiones desde su mismo origen.

Si las peticiones salen desde el mismo origen (localhost) el Backend acepta la petici贸n, pero cuando se tienen diferentes origenes (clientes, un front o un movil).

Insomnia o postamn y este tipo de herramientas nos abstraen de ver este error porque por debajo usan un proxy que cambia el origen.

### Las formas de resolver el problema es la siguiente:

# Deploy con heroku
npm i -g heroku
heroku --version
heroku login
heroku create
git remote -v
  "engines":{
    "node": "14.x"
  }
Heroku local web
https://git.heroku.com/peaceful-headland-45148.git







### PARA APRENDER
-Serie de videos de buenas practicas hacker nomada de node js
- Tareas en segundo plano para no sobrecargar el servidor
- Tareas en cola - Queu task
- Web kocks
- Documentar con swager
- Patrones de dise帽o (observador, mediador, inyecci贸n de dependencias, factory, builder, singelton, estrategia, estado)


