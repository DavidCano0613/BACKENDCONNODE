# CREACÍON DE UN BACKEND CON NODE JS

## PASOS PARA CREAR UN BACKEND CON EXPRESS JS

1. Elegir una arquitectura de software
2. Configuración del entorno de desarrollo y de producción con buenas practicas.
3. Instalación de la librerias que seran necesarias para el desarrollo del proyecto.
4. Creación del servidor con express js
5. Separar responsabilidades en carpetas como lo indique la arquitectura elegida:
6. Creación de la capa de routing.
7. Creación de los middlewares.
8. Creación de la capa de servicios.
9. Establecer la capa de acceso a datos (_conexión con bases de datos_).
10. Capa de seguridad, establecer todo lo relacionado con autenticación y autorización.
11. Creación de pruebas y tests.
12. Deploy.

---

# The Clean Architecture.

Es un estilo de arquitectura de software que funciona separando el software en capas.

> La capa mas pequeña es la de entidades en esta capa es donde se definen las entidades base del negocio en este proyecto por ejemplo, usuarios, productos, ordenes de compra, categorias etc...

> Luego se tiene una capa de casos de uso, aqui normalmente se tiene todo lo relacionado a la lógica de negocio y se ven los servicios en esta capa.

> Luego estan los controladores que son los que brindan acceso a estos servicios, aquí se ve el routing y los middlewares que ayudan a capturar errores y a hacer validaciones.

Imagen:
![](./assets/theclena.png)

De una forma más transparente:
![](./assets/Captura%20de%20pantalla%202022-07-31%20140441.png)


> Finalmente esta la capa de los clientes que seran todos los dispositivos conectados a esa API

> Resumen del flujo: Los clientes se conectan con los controladores, estos asu vez se conectan con los servicios y los servicios se encargan de conectarse con las bases de datos o su respectiva fuente de información y realizar una lógica de negocio. 

![](./assets/Captura%20de%20pantalla%202022-07-31%20170216.png)


---

# Configuración de entorno de etorno de desarrollo y de producción con buenas practicas:

Establecer una buena configuración servira para trabajar de una forma más apropiada. 

- Crear un buen **git ignore:** Este se coloca en el directorio raiz del proyecto:  https://www.toptal.com/developers/gitignore.
- Configuración del editor de código: Es recomendable para que todos los desarrolladores tengan la misma configuración en su editor de código. **Tener la extensión editorconfig**. Se puede establecer una configuración que lo que haga sea formatear el editor de código para que todos trabajen de la misma manera.
- Nodemon como servidor de desarrollo: Crear algunas tareas o scripts en el package json.
- Linters:
- Pipelines:
- Instalación de paquetes: npm i nodemon eslint eslint-config-prettier eslint-plugin-prettier prettier -D

¿Qué es el archivo .gitignore?
https://www.freecodecamp.org/espanol/news/gitignore-explicado-que-es-y-como-agregar-a-tu-repositorio/#:~:text=gitignore%20%2C%20es%20un%20archivo%20de,puedes%20crear%20un%20archivo%20global%20.

¿Porqué configurar el editor de código?
https://www.kodetop.com/editorconfig-para-configurar-tu-editor-de-codigo/

¿Que es linting?
https://kb.rolosa.com/que-es-un-linter/

Scrips de npm
https://lenguajejs.com/npm/administracion/scripts-de-npm/

Todo sobre el package json
https://medium.com/noders/t%C3%BA-yo-y-package-json-9553929fb2e3


---
# Instalación de la librerias que seran necesarias para el desarrollo

Para el desarrollo de este curso se instalaran las siguientes librerias:

1. Express
2. Boom
3. Joi

---

# Creación del servidor con express js

EXPRESS: Es una libreria que permite gestionar de una mejor manera un servidor web. Express tiene una función que permite crear un servidor con: nombre_servidor = express()

La instacia de express trae en forma de función los métodos/verbos http.
**get post put patch y delete**.

A estas funciones se les puede pasar los paths (_URLS,Endpoints_) a los cuales los clientes van a atacar con los verbos http, esto se puede entender de la siguiente forma:
>El método http recibe dos parametros la URL y una función de tipo callback que ejecuta cierta lógica de programación CUANDO se ataque a ese endpoint. El callback recibe dos objetos que son *REQUEST AND RESPONSE*.

Los objetos **request y response** son muy importante puesto que por medio de estos es que se envía y recibe información. En el curso de Node js se amplifica que propiedades y métodos contienen estos objetos y para que sirven.

Express permite trabajar con el REQUEST.BODY de una forma más amigable. Express contiene algo llamado *parser* que ayuda a tomar el body que viene en forma de un stream y _parsearlo_ a algun tipo de dato, ya sea un archivo de texto, un json o lo que sea. Lo más usual es parsearlo a JSON.

---

# Separación de responsabilidades (Single Responsability Principle)

Hace parte de los principios SOLID. En este caso *Single Responsability Principle* establece que es una mala practica tener código que hace de todo, es decir si una función tiene como nombre sumar, no debería en su cuerpo estar calculando integrales. Esto se puede llevar al plano de los archivos, routing, clases, modulos, servicios y más|.


---
# Creación de la capa de routing

Como se menciono the clean architecture establece que el routing hace parte de la capa de acceso a los servicios y también se encarga de proporcionar los EndPoints a los cuales los clientes se van a conectar para acceder a estos recursos. Sin embargo es una pesima practica definir todo el routing en el archivo index donde se levanta el servidor.

Los routers en express son middlewares que permiten agrupar rutas para así separar la lógica de los endpoints.

De acuerdo con el Single Responsability Principle todo el routing deberia dividirse en archivos que se encarguen de definir las rutas de cada endpoint en espesifico. Lo ideal es crear una carpeta que contenga todo el routing.

El nombre que se le dan a estos archivos dependen del equipo de desarrollo.

Se debe definir un path principal para ese router, es decir debe tener como su entorno propio
---
# Creación de los middlewares

### Que son los middlewares y para que sirven

Como se ha observado anteriormente en los Endpoints se establece cierta lógica. Pero que tal si se necesita ejecutar una función antes de que se ejecuta la lógica del endpoint?

Los middlewares sirven para eso y es porque son funciones que se ejecutan de forma previa a la lógica que hay en el Endpoint. 

### Sintaxis
Express dispone del método use() el cual recibe como parametro el request y el response y un método muy importante llamado next el cual se explica despues de las propidades de los middlewares. 

### Propiedades de los middlewares en express JS

1. **Pueden ser utilizados de forma global:** Ejemplo: para capturar errores a nivel general en toda la aplicación. 

2. **Pueden ser utilizados a nivel de cada endpoint o de un grupo de endpoints:** De estar forma el middleware una vez se ejecuta, llama a la función del endpoint al que se haya atacado. Esto también lo hace next()

3. **Funcionan de forma secuencial** Una de sus propiedades es que pueden funcionar de forma secuencial. Cada middleware puede tener una función  espesifica, una vez termine... sigue el otro middleware con otra lógica diferente. Es como tener funciones tradicionales conectadas en cadena, se ejecuta una y le pasa el flujo a la siguiente y asi sucesivamente. Un middleware puede bloquear, Es decir si cierta lógica no se cumple no se permite seguir con el siguiente middleware.
 
4. **El método Next():** El método NEXT (que también viene como parámetro) es un callback que permite que el siga el proximo middleware o en su defecto la proxima función callback que tenga el endpoint al que se ha atacado **(Hay un dilema y es que express no diferencia muy bien entre middlewares y rutas, practicamente las funciones que se ejecutan en las rutas son middlewares también)**.


### Uses Cases
- Funcionan como pipes
- Validar datos
- Capturar errores
- Validar permisos
- Controlar accesos

### Middleware de tipo error.
Tienen el parámetro error de primero.
Es util para crear un middleware global que acompañe a todas las peticiones de tal manera de que si sale un error se capture este primero que todo y luego se siga con lo demas

Este tipo de middlewares se deben crear despues de hacer todo el Routing

### Middleware de tipo validación
Otro uso muy común de los middlewares es validar los datos que vienen desde el cliente(front-end). Para esto existe una librería llamada Joi.

Como backend un desarrollador debería asgurarse de que lo que le envia el front-end cumple con la integridad de datos, que un precio este un formato adecuado o por ejemplo que se envien los atributos que se esperan, con los middlewares se pueden capturar este tipo de errores antes de que lleguen a la capa de servicios.


---
# Creación de la capa de servicios

Es la capa donde se pone la lógica del negocio como tal. Esta capa encapsula todos los casos de uso.

Los servicios tienen la lógica del negocio y obtienen información por medio de librerias a una base de datos o de una api externa. Luego estos servicios pueden sen consumidos por los controladores. Practicamente en esta capa se centraliza la lógica de la aplicación. Pero esta capa es accedida una vez se ha cumplido con todo lo que los controladores y middlewares tienen que hacer, ya sea: Capturar errores, hacer validaciones, verificar autenticación y autorización.


---

# Considereaciones para hacer deploy

1. Evaluar los Cors
2. Que la api este en un servidor https
3. Correr todos los procesos de build (typescript o sass por ejemplo)
4. Remover todos los console.log
5. Seguridad (helmet)
6. Testing

# CORS
Uno de los problemas más comunes es el problema de cors, es un problema muy común a la hora de conectar el **Back-end con el Front-end**.

### Cross.Origin Resource Sharing
Significa que los servidores tienen una protección por defecto y es que solo aceptan peticiones desde su mismo origen.

Si las peticiones salen desde el mismo origen (localhost) el Backend acepta la petición, pero cuando se tienen diferentes origenes (clientes, un front o un movil).

Insomnia o postamn y este tipo de herramientas nos abstraen de ver este error porque por debajo usan un proxy que cambia el origen.

### Las formas de resolver el problema es la siguiente:


# Deploy con heroku
npm i -g heroku
heroku --version
heroku login
heroku create
git remote -v
  "engines":{
    "node": "14.x"
  }
Heroku local web
https://git.heroku.com/peaceful-headland-45148.git


---
# CONEXIÓN A BASE DE DATOS


---
### PARA APRENDER
- Tareas en segundo plano para no sobrecargar el servidor
- Tareas en cola - Queu task
- Web kocks 
- Documentar con swager
- Patrones de diseño (observador, mediador, inyección de dependencias, factory, builder, singelton, estrategia, estado)