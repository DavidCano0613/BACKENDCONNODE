# CREAC√çON DE UN BACKEND CON NODE JS
## PASOS PARA CREAR UN BACKEND
1. Elegir la arquitectura de software m√°s adecuada para el caso.
2. Configurar del entorno de desarrollo y de producci√≥n con buenas practicas.
3. Instalar las librerias que seran necesarias para el desarrollo del proyecto.
4. Creaci√≥n del servidor con EXPRESS.JS
5. Separar responsabilidades como lo indique la arquitectura elegida
6. Crear la capa de routing.
7. Crear la capa de middlewares.
8. Crear la capa de servicios.
9. Crear la capa de librerias y establecer la conexi√≥n con bases de datos.
10. Crear la capa de seguridad, establecer todo lo relacionado con autenticaci√≥n y autorizaci√≥n.
11. Crear y correr de pruebas.
12. Hacer deploy.
---

# 1) The Clean Architecture.
Es un estilo de arquitectura de software que funciona separando el software en capas.

> La capa mas peque√±a es la de entidades en esta capa es donde se definen las entidades base del negocio en este proyecto por ejemplo, usuarios, productos, ordenes de compra, categorias etc...

> Luego se tiene una capa de casos de uso, aqui normalmente se tiene todo lo relacionado a la l√≥gica de negocio y se ven los servicios en esta capa.

> Luego estan los controladores que son los que brindan acceso a estos servicios, aqu√≠ se ve el routing y los middlewares que ayudan a capturar errores y a hacer validaciones.

Imagen:
![](./assets/theclena.png)

De una forma m√°s transparente:
![](./assets/Captura%20de%20pantalla%202022-07-31%20140441.png)

> Finalmente esta la capa de los clientes que seran todos los dispositivos conectados a esa API.

> Resumen del flujo: Los clientes se conectan con los controladores, estos a su vez se conectan con los servicios y los servicios se encargan de conectarse con las bases de datos o su respectiva fuente de informaci√≥n y realizar una l√≥gica de negocio.

![](./assets/Captura%20de%20pantalla%202022-07-31%20170216.png)


---
# 2) Configuraci√≥n de entorno de etorno de desarrollo y de producci√≥n con buenas practicas:

Establecer una buena configuraci√≥n servira para trabajar de una forma m√°s apropiada.

- Crear un buen **git ignore:** Este se coloca en el directorio raiz del proyecto:  https://www.toptal.com/developers/gitignore.
- Configuraci√≥n del editor de c√≥digo: Es recomendable para que todos los desarrolladores tengan la misma configuraci√≥n en su editor de c√≥digo. **Tener la extensi√≥n editorconfig**. Se puede establecer una configuraci√≥n que lo que haga sea formatear el editor de c√≥digo para que todos trabajen de la misma manera.
- Nodemon como servidor de desarrollo: Creaaci√≥n algunas tareas o scripts en el package json.
- Linters: Eslint
- Pipelines:

### Instalaci√≥n de paquetes:
npm i nodemon eslint eslint-config-prettier eslint-plugin-prettier prettier -D

---
# Instalaci√≥n de la librerias que seran necesarias para el desarrollo

A continuaci√≥n se presenta un paquete de librerias que pueden ser utiles para crear backend con node js:

1. Express: npm i express

2. Eslint:

3. nanoid

4.

2. Boom: npm i @hapi/boom

3. Joi:
npm install --save joi
npm install --save-dev @types/joi

4. Postgres:
* npm install --save pg pg-hstore
* npm install --save mysql2
* npm install --save sqlite3
* npm install --save tedious // MSSQL

5. Cors: npm i cors

6. sequelize:
* npm install --save sequelize
* npm i sequelize-cli -D: Para migraciones
*

npm i dotenv

---
# Creaci√≥n del servidor con express JS

EXPRESS: Es una libreria que permite gestionar de una mejor manera un servidor web.

La instacia de express trae en forma de funci√≥n los m√©todos/verbos http.
**get post put patch y delete**.

A estas funciones se les puede pasar los paths (_URLS,Endpoints_) que no son m√°s que un punto final en el servidor donde se aloja un recurso. Los clientes van a solicitar recursos a esas URLS con los verbos http y va haber un handler que se ejecuta cuando la ruta coincide. Esto se puede entender de la siguiente forma:

>El m√©todo http recibe dos parametros la URL y una funci√≥n de tipo callback llamada handler que ejecuta cierta l√≥gica de programaci√≥n CUANDO se ataque a ese EAndpoint. El callback recibe dos objetos que son *REQUEST AND RESPONSE*.

Los objetos **request y response** son muy importante puesto que por medio de estos es que se recibe y envia la informaci√≥n.

Express permite trabajar con el REQUEST.BODY de una forma m√°s amigable.
Express contiene algo llamado *parser* el cual es un middleware que ayuda a tomar el body que viene en forma de un stream y _parsearlo_ a algun tipo de dato, ya sea un archivo de texto, un json o lo que sea. Lo m√°s usual es parsearlo a JSON. Este se puede establecer en el index de forma global para que a todos los endpoints les llegue el body parseado.

---
# Separaci√≥n de responsabilidades (Single Responsability Principle)

Hace parte de los principios SOLID. En este caso *Single Responsability Principle* establece que es una mala practica tener c√≥digo que hace de todo, es decir si una funci√≥n tiene como nombre sumar, no deber√≠a en su cuerpo estar calculando integrales. Esto se puede llevar al plano de los archivos, routing, clases, modulos, servicios y m√°s. Es aqui donde se lleva realmente acabo la arquitectura.

---
# Creaci√≥n de la capa de routing y controladores

* Como se menciono the clean architecture establece que el routing hace parte **de la capa de acceso a los servicios** y tambi√©n se encarga de proporcionar los EndPoints a los cuales los clientes se van a conectar para acceder a los recursos. Sin embargo, es una pesima practica definir todo el routing en el archivo index donde se levanta el servidor.
* Express cuenta con sistema de enrrutamiento el cual permite separar las rutas.
* Los Routers en express son middlewares que permiten agrupar rutas para as√≠ separar la l√≥gica de los endpoints.
* Todo el routing deberia dividirse en archivos que se encarguen de definir las rutas de cada endpoint en espesifico.
* Lo ideal es crear una carpeta que contenga todo el routing.
* El nombre que se le dan a estos archivos dependen del equipo de desarrollo.
* Se debe definir un path principal para ese router, es decir debe tener como su entorno propio.
---
# Creaci√≥n de los middlewares

## Que son los middlewares y para que sirven
Como se ha observado anteriormente en los Endpoints se establece cierta l√≥gica. Pero ¬øque tal si se necesita ejecutar una funci√≥n antes de que se ejecute la l√≥gica del endpoint, como por ejemplo, validar permisos o validar que la data venga como se espera?

Los middlewares sirven para eso, pues son FUNCIONES que se ejecutan de **FORMA PREVIA** a los handlers de los endpoints, es muy importante hacer esta notaci√≥n y es que antes de que la petici√≥n llegue al endpoint y se ejecute la l√≥gica que tiene el handler asociado a este, se ejecuta primero el middleware que esta definido en esa ruta.

## Sintaxis
> Se crea una funci√≥n normal con la logica que va contener ese middleware, luego ya sea a nivel de toda la app o de un grupo de endpoints espesificos se llama al m√©todo USE.

> Express dispone del **m√©todo use()** el cual recibe como parametro el **request y el response** y un m√©todo muy importante llamado **next** el cual se explica despues de las propidades de los middlewares. Entonces en ese orden de ideas los middlewares se crean asi:
- algo.use()

## Propiedades de los middlewares en express JS

1. **El orden es importante:** Los middlewares se ejecutan en el mismo orden que se llamen en el c√≥digo

2. **Pueden ser utilizados de forma global:** Ejemplo: para capturar errores a nivel general en toda la aplicaci√≥n, en este caso pueden ponerse en el index de la app.

3. **Pueden ser utilizados a nivel de cada endpoint o de un grupo de endpoints:** De esta forma el middleware una vez se ejecuta, llama al handler del endpoint al que se haya atacado. Esto tambi√©n lo hace next()

4. **Funcionan de forma secuencial** Una de sus propiedades es que pueden funcionar de forma secuencial. Cada middleware puede tener una funci√≥n  espesifica, una vez termine... sigue el otro middleware con otra l√≥gica diferente. Es como tener funciones tradicionales conectadas en cadena, se ejecuta una y le pasa el flujo a la siguiente y asi sucesivamente. Un middleware puede bloquear el flujo, Es decir si cierta l√≥gica no se cumple no se permite seguir con el siguiente middleware o no permite acceder a la siguiente capa, esto viene muy bien a la hora de hacer validaciones.

5. **El dichoso m√©todo Next():** El m√©todo NEXT (que tambi√©n viene como par√°metro en el use()) es un callback que permite que el siga el proximo middleware o en su defecto el handler que tenga el endpoint. **(Hay un dilema y es que express no diferencia muy bien entre middlewares y rutas, practicamente las funciones (handlers) que se ejecutan en las rutas son middlewares tambi√©n)**.
## Uses Cases
- Funcionan como pipes
- Validan datos
- Capturan errores
- Validan permisos
- Controlan accesos

## Middleware de tipo error.
Es ideal que antes de que la petici√≥n llegue al endpoint se capturen los posibles errores. Sin embargo, estos no deben devolverse a secas. Los errores hay que gestionarlos, darles un formato y mandarlos de una forma clara y bien presentada al cliente.

### Sintaxis middleware de error
Tienen el par√°metro error de primero **(error,req,res,next).**

Son utiles para crear un middleware GLOBAL (funcionan a nivel de todos los endpoints) que acompa√±e a todas las peticiones de tal manera de que si sale un error este se capture y se le de un formato para retornalo, **¬øque formato?** ejemplo: _el tipo de error, el codigo de estado y un mensaje._.

Este tipo de middlewares se deben crear despues de hacer todo el Routing.
Este tipo de middlewares se crean en un carpeta y se llaman donde se requiran y se ponen tambi√©n en el routing.

## Libreria Boom
Esta libreria ayuda a gestionar de forma m√°s eficiente lo errores. Pues hasta el momento se ha enviado el status code, message, entre otros de forma que siempre se debe poner el status code manualmente. Boom ayuda a ahorrar esta molestia.

isBoom: Si es un error de tipo boom
output: Toda la informacion del error

#### Ventajas de usar Boom:
- Ayuda a no tener que poner el status code de forma manual
- Gestiona mejor los errores


## Middleware de tipo validaci√≥n
Otro uso muy com√∫n de los middlewares es validar los datos que vienen desde el cliente (front-end). Para esto existe una librer√≠a llamada Joi.

Como backend un desarrollador deber√≠a asgurarse de que lo que le envia el front-end cumple con la integridad de datos, que un precio este un formato adecuado o por ejemplo que se envien los atributos que se esperan, con los middlewares se pueden capturar este tipo de errores antes de que lleguen a la capa de servicios.


---
# Creaci√≥n de la capa de servicios

Es la capa donde se pone la l√≥gica del negocio como tal. Esta capa encapsula todos los casos de uso.

Los servicios tienen la l√≥gica del negocio y obtienen informaci√≥n por medio de librerias a una base de datos o de una api externa. Luego estos servicios pueden sen consumidos por los controladores. Practicamente en esta capa se centraliza la l√≥gica de la aplicaci√≥n. Pero esta capa es accedida una vez se ha cumplido con todo lo que los controladores y middlewares tienen que hacer, ya sea: Capturar errores, hacer validaciones, verificar autenticaci√≥n y autorizaci√≥n.
---
# VARIABLES DE AMBIENTE / ENTORNO
Tener archivos de configuraciones separados en diferentes ambientes es una buena practica. Cuando una aplicaci√≥n web se va a a desplegar se esta hablando de que una aplicaci√≥n se va usar al menos en dos ambientes diferentes. _Producci√≥n y desarrollo_.

En las empresas grandes existen m√°s entornos.

Para cuyos casos es necesario para cada entorno crear sus respectivos archivos de configuraci√≥n.

Las variables de entorno son variables dinamicas que afectan a el comportamiento de una aplicaci√≥n y son usadas cuando una aplicaci√≥n corre en diferentes entornos, por ejemplo, el de desarrollo o el de producci√≥n.

## USOS M√ÅS COMUNES:
1. Almacenar informaci√≥n sensible.
2. Para aplicar configuraciones que sean espesificas para entornos de desarrollo.
3. Para despliegue.

### Cuando se crean aplicaciones con Node JS del lado del back-end es muy usual conectarse a servicios de terceros, ejemplos:

* Bases de datos: Cuando se establece una conexi√≥n a una base de datos desde un back-end se debe ingresar la informaci√≥n necesaria para hacer de forma exitosa dicha conexi√≥n, informaci√≥n como el usuario de la base de datos, la contrase√±a, el host, el puerto entre otros.

* APIS de terceros: Estos servicios brindan un token y client_id que sirven para conectarse a estos servicios.

## Formas de crear las conexiones con bases de datos.
> Tipeando de forma directa: Una forma de hacer estas conexiones es tipeando de forma explicita en el c√≥digo, en otras palabras quemando los datos, todos esos datos LOS CUALES POR SUPUESTO **SON MUY SENSIBLES** y por lo tanto es una **pesima** practica hacerlo de esta forma. Al publicar esto en un repositorio todo el mundo tiene acceso a esa informaci√≥n y podran acceder a la base de datos.

> Usando variables de entorno: Estas le a√±aden una capa de seguridad al c√≥digo dado que ya no muestra los datos de forma quemada.

## Uso de variables de entorno en Node JS

### Objeto process.env:
process.env es un objeto **GLOBAL** que contiene como propiedades todas las variables de entorno.

Se puede crear un objeto config que contenga todas las variables de etorno. Una practica que suele seguirse es protegerlas un poco y guardar todas estas variables de entorno en una URL con todo el esquema de conexi√≥n.

Para acceder al archivo .env y cargar las variables a un proceso de node, se debe instalar un paquete para poder acceder a estas y se llama al m√©todo config.

Es un archivo que va contener todas las variables de entorno:
- Instalar el modulo dotenv
- Crear la carpeta config
- Crear el archivo .env
- Crear el archivo .env.example
- **No se debe subir el repositorio el .env**
- **Se pone en el repositorio el .env.example**
- Todas se escriben en UPPERCASE
- Si hay varias palabras se separan por _
- Creaci√≥n de de las variables de entorno
- Crear el script

### Archivo .env y .env.example
Se deben separar debido a que en el .env existe informaci√≥n sensible. Sin embargo, es necesario mostrar cuales son esas variables de etorno, por lo tanto, en el .env.example se ponen como un ejemplo de cuales son sin ponerlas de forma explicita.

---
# CAPA DE librerias
Estan se encargan de todo lo que tiene que ver con conexi√≥n con terceros, es en esta carpeta donde se crean todos los archivos que se encargan de conectar a la back-end con terceros como **Bases de datos** y **APIS**

# CONEXI√ìN A BASE DE DATOS
Existen diversas formas de conectar el **Backend** con **bases de datos**.

1. La m√°s com√∫n, por lo menos para empezar a entender el como gestionar informaci√≥n de una base de datos desde el backend es descargando un SGDB y buscando la libreria que permita conectar a Node js con dicho motor. Sin embargo, la forma recomendada es con un pooling.

> Conexi√≥n con POSTGRESQL: Para conectar Node JS con una base de datos pg: https://node-postgres.com/
> Conexi√≥n con MYSQL: Para conectar Node JS con una base de datos mysql: https://node-postgres.com/
> Conexi√≥n con SQLSERVER: Para conectar Node JS con una base de datos sqlserver: https://node-postgres.com/

## Pooling
Cuando se trabaja con bases de datos en el backend, cada vez que se hace una operaci√≥n contra la misma, primero se debe generar una conexi√≥n con la base de datos.

Por lo que tener que llamar al m√©todo que conecta la base de datos con el backend por cada vez que se quiere hacer una operaci√≥n se vuelve muy tedioso. Ademas, eso esta mal porque puede sobrecargar el servidor de request. Entonces, esto es un problema porque por cada request se crea una negociacion con la base de datos, se tarda 20ms o mas, y asi se va saturando el servidor. Por lo tanto el SGDB proporcionan una interfaz llamada pool.

Un pool de conexiones basicamente es un conjunto limitado de conexiones a una base de datos, que es manejado por un servidor de aplicaciones de forma tal, que dichas conexiones pueden ser reutilizadas por los diferentes usuarios.

Es como un lugar en el que se centralizan estas conexiones para no tenerlas que estar llamando cada vez, si no desde el pool. Lo que hace el pool es sencillamente es ser un mediador entre las bases de datos y el cliente.

Entonces a medida que los clientes empiecen a hacer consultas, la aplicacion de manera asincrona se conectara con el pool y el pool se encargara tanto de abrir o cerrar conexiones para que la informacion siga trabajando de manera eficiente.

![](./assets/OOFTe.png)


---
# ORM: Object-Relational mapping
Un ORM es un modelo de programaci√≥n es una capa que permite mapear las estructuras de una base de datos relacional en entidades de la programaci√≥n orientada a objetos. Es decir, el ORM toma las tablas y las convierte en POO basicamente. Es como usar programaci√≥n orientada a objetos para hacer operaciones contra la base de datos. El ORM es agnostico, pues este se puede usar en cualquier SGDB.

Al abstraer este tipo de programaci√≥n, se delega su implementaci√≥n al Backend, es decir, le a√±adimos una de responsabilidad a la capa transaccional del servidor:

‚ú®Los beneficios son los siguientes:

Acciones como CRUD (Create, Read, Update, Delete) son administradas mediante ORM.
La implementaci√≥n de seeds o semillas, nos permiten recuperar, mediante c√≥digo, la estructura de una BD.

## EL DAO Y DTO
Una de las bases te√≥ricas para entender este modelo es mediante el conocimiento del DAO (Data Access Object) y DTO (Data Transfer Object), los cuales nos permiten desestructurar un ORM en m√≥dulos de abstracci√≥n para **acceder a la DB** y **transferir datos desde la misma DB**, respectivamente hablando.

üôÉLos contras ser√≠an:
- Delegaci√≥n de responsabilidades al server.
- Descentralizaci√≥n de trabajo, directa, de una Data Base.

## SEQUELIZE
* npm install --save sequelize
## Instalar segun la base de datos a utilizar:
* npm install --save pg pg-hstore
* npm install --save mysql2
* npm install --save sqlite3
* npm install --save tedious / MSSQL

## Caracteristicas de Sequelize
Sequelize gestiona la conexi√≥n con la base de datos.

## Instalaci√≥n y configuraci√≥n
Lo primero que estamos haciendo es importar la clase Sequelize despues lo que se hace es crear una nueva instancia de esta clase que recibe como par√°metros en su constructor, el nombre de la base de datos, el nombre del usuario, la contrase√±a, y un objeto de configuraci√≥n donde especificamos el host de nuestra base de datos, el dialect que es donde ponemos que base de datos se esta utilizando.

Sequelize permite utilizar consultas de forma directa con sql:

## Modelos en sequelize

Los modelos en sequelize nos permiten representar las tablas y manipular estos datos, un modelo se define de la siguiente manera:

Usando la clase class model Extends Model.
Usando el m√©todo sequelize.define()
Consultar los tipos de datos y configuraciones de columnas que admite sequelize.
Por defecto el nombre que se le de al modelo se crea en la base de datos
Se puede crear explicitamente el nombre de la tabla aunque el modelo tenga otro nombre

### Create Update and Delete
### Sincronizaci√≥n de Modelos.

Aqu√≠ es donde entra en juego la sincronizaci√≥n de modelos. Un modelo se puede sincronizar con la base de datos llamando a model.sync(options), una funci√≥n as√≠ncrona (que devuelve una Promesa). Con esta llamada, Sequelize realizar√° autom√°ticamente una consulta SQL a la base de datos. Tenga en cuenta que esto cambia solo la tabla en la base de datos, no el modelo en el lado de JavaScript.

>User.sync()- Esto crea la tabla si no existe (y no hace nada si ya existe)
>User.sync({ force: true })- Esto crea la tabla, borrandola primero si ya exist√≠a
>User.sync({ alter: true })- Esto verifica cu√°l es el estado actual de la tabla en la base de datos (qu√© columnas tiene, cu√°les son sus tipos de datos, etc.), y luego realiza los cambios necesarios en la tabla para que coincida con el modelo.

>Se puede hacer a nivel de un solo modelo Model.sync()

>Se puede hacer a nivel generl todos los modelos existentes sequelize.sync

## Consultas
Para hacer consultas con Sequelize
Se puede mapear con POO o se le puede mandar una consulta directa tipo SQL, la informaci√≥n la devuelve en un array, con dos posiciones la primera es la data como tal y la otra es meta data que viene a ser como informac√≠on adicional de la consulta.

## Cambio de base de datos

## Migraciones
Cuando una aplicaci√≥n esta en producci√≥n esta el dilema de como se sincroniza la base de datos con lo que se va haciendo en local ?

El problema de sequelize.sync() es que empieza a leer los modelos, crea tablas y hace relist (se sobrescribe informaci√≥n), no se aconseja que se corra esto as√≠ en producci√≥n. Es mejor sincronizar con un sistema de migraciones.

Las migraciones son como un sistema de control de versiones para bases de datos.

Mantienen un hisotrial del esquema que se va manteniendo en la base de datos.

Usualmente se va tener una primer migracic√≥n que es la que crea toda la estructura inicial y todas las tabals como lass columnas con sus respectivos tipos de datos. Luego a medida que se van a√±adiendo campos o haciendo alguna modificacion deberiamos tener esto en un sistema de migraciones, ¬øPorque? esto es debido a que cuando un sistema esta corriendo en producci√≥n, se debe replicar todo y con las migraciones se pueden enviar nuevos **releases**. El sistema en producci√≥n debe saber en que momento de la migraci√≥n para que no se rescriban datos ni repita informaci√≥n.

Nuevamente la funci√≥n sync crea nuevamente tablas y dem√°s lo cual es muy peligroso para
cuando el sistema esta en producci√≥n dado que se puede sobrecargar al estar creando tablas una y otra vez cuando se lanza un nuevo feature, e incluso puede haber pedida de informaci√≥n.

La migraci√≥n corre o toma como punto de referencia la ultima que se haya corrido.

## ¬øCOMO CREAR MIGRACIONES EN SEQUELIZE?

Se instala npm i sequelize-cli -D

>Agregar un archivo de configuraci√≥n en la carpeta raiz llamado -sequelizerc

>Las migraciones van a tener su propia conex√≠on independiente a la que ya tiene la aplicaci√≥n

>Se deben declarar los ambientes de development y production

> A diferencia de laravel que trae los comandos de terminal por defecto, en sequelize debemos crearlos y la forma de hacerlo es creando scripts de NPM.

## Seeders
### UP:
### DOWN:
### Comandos de migraciones

* sequelize-cli db:migrate: Run pending migrations.
* sequelize-cli db:migrate:schema: timestamps:add Update migration table to have timestamps.
* sequelize-cli db:migrate:schema: timestamps:add Update migration table to have timestamps
* sequelize-cli db:migrate:status: List the status of all migrations
* sequelize-cli db:migrate:undo: Reverts a migration
* sequelize-cli db:migrate:undo: all Revert all migrations ran

* sequelize-cli db:seed: Run specified seeder
* sequelize-cli db:seed:undo: Deletes data from the database
* sequelize-cli db:seed:all: Run every seeder
* sequelize-cli db:seed:undo:all: Deletes data from the database

* sequelize-cli db:create Create database specified by configuration
* sequelize-cli db:drop Drop database specified by configuration
* sequelize-cli init Initializes project
* sequelize-cli init:config Initializes configuration
* sequelize-cli init:migrations Initializes migrations
* sequelize-cli init:models Initializes models
* sequelize-cli init:seeders Initializes seeders
* sequelize-cli migration:generate Generates a new migration file
[aliases: migration:create]
* sequelize-cli model:generate Generates a model and its migration
[aliases: model:create]
* sequelize-cli seed: generate Generates a new seed file.
* generate create-user
---

Cuando se corre el comanndo run esot genera una tabla llamada SequelizeMeta esta tabla es clave, esto es lo que se permite que se haga el tracking (historico) de la migraci√≥n, es como un registro o historial por lo cual si se vuelve a correr la migraci√≥n ya no va a rescirbir informaci√≥n porque ya tiene registro de que esa migraci√≥n se hizo eso permite tener un orden a la hora de mandar cambios a producci√≥n

Para hacer modificaciones a tablas ya creadas se tiene que ir al modelo se hace el camibio pertinente y se informa de esto a la migraci√≥n.


## Relaciones en sequelize

1. One to one relation

Tiene dos m√©todos para expresar relaciones esto dependiendo de quien va cargar con las relaci√≥n.

HasOne ->
BelongsTo ->



One to many
Many to Many


https://pigexception.wordpress.com/2016/03/26/patron-de-diseno-dao/


---
# Considereaciones para hacer deploy

1. Evaluar los Cors
2. Que la api este en un servidor https
3. Correr todos los procesos de build (typescript o sass por ejemplo)
4. Remover todos los console.log
5. Seguridad (helmet)
6. Testing

# CORS
Uno de los problemas m√°s comunes es el problema de cors, es un problema muy com√∫n a la hora de conectar el **Back-end con el Front-end**.

### Cross.Origin Resource Sharing
Significa que los servidores tienen una protecci√≥n por defecto y es que solo aceptan peticiones desde su mismo origen.

Si las peticiones salen desde el mismo origen (localhost) el Backend acepta la petici√≥n, pero cuando se tienen diferentes origenes (clientes, un front o un movil).

Insomnia o postamn y este tipo de herramientas nos abstraen de ver este error porque por debajo usan un proxy que cambia el origen.

### Las formas de resolver el problema es la siguiente:

# Deploy con heroku
npm i -g heroku
heroku --version
heroku login
heroku create
git remote -v
  "engines":{
    "node": "14.x"
  }
Heroku local web
https://git.heroku.com/peaceful-headland-45148.git


<<<<<<< HEAD
=======
---
# CAPA DE librerias
Estan se encargan de todo lo que tiene que ver con conexi√≥n con terceros, es en esta carpeta donde se crean todos los archivos que se encargan de conectar a la back-end con terceros como **Bases de datos** y **APIS**


# CONEXI√ìN A BASE DE DATOS
Existen diversas formas de conectar el backend con bases de datos

1. La m√°s com√∫n, por lo menos para empezar a entender el como gestionar informaci√≥n de una base de datos desde el backend es descargando un SGDB y buscando la libreria que permite conectar a Node js con dicho motor.

> Conexi√≥n con POSTGRESQL: Para conectar Node JS con una base de datos pg: https://node-postgres.com/
> Conexi√≥n con MYSQL: Para conectar Node JS con una base de datos mysql: https://node-postgres.com/
> Conexi√≥n con SQLSERVER: Para conectar Node JS con una base de datos sqlserver: https://node-postgres.com/

## Pooling
Cuando se trabaja con bases de datos en el backend, cada vez que se hace una operaci√≥n contra la misma, antes se debe generar una conexi√≥n con la base de datos. Por lo que tener que llamar al m√©todo que conecta la base de datos con el backend por cada vez que se quiere hacer una operaci√≥n se vuelve muy tedioso. Ademas, eso esta mal porque puede sobrecargar el servidor de request. Entonces, esto es un problema porque por cada request se crea una negociacion con la base de datos, se tarda 20ms o mas, y asi se va saturando el servidor. Por lo tanto SGDB proporcionan una interfaz llamada pool.

Un pool de conexiones basicamente es un conjunto limitado de conexiones a una base de datos, que es manejado por un servidor de aplicaciones de forma tal, que dichas conexiones pueden ser reutilizadas por los diferentes usuarios. Es como un lugar en el que se centralizan estas conexiones para no tenerlas que estar llamando cada vez, si no desde el pool. Lo que hace el pool es sencillamente es ser un mediador entre las bases de datos y el cliente. Entonces a medida que los clientes empiecen a hacer consultas, la aplicacion de manera asincrona conectara con el pool y el pool se encargara tanto de abrir o cerrar conexiones para que la informacion siga trabajando de manera eficiente.
![](./assets/OOFTe.png)


---

# ORM: Object-Relational mapping


Un ORM es un modelo de programaci√≥n que permite mapear las estructuras de una base de datos relacional en entidades de la programaci√≥n orientada a objetos. Es decir, el ORM toma las tablas y las convierte en POO. Es como usar programaci√≥n orientada a objetos para hacer operaciones contra la base de datos. El ORM es agnostico, pues este se puede usar en cualquier SGDB.

Al abstraer este tipo de programaci√≥n, se delega su implementaci√≥n al Backend, es decir, le a√±adimos una de responsabilidad a la capa transaccional del servidor:
.
‚ú®Los beneficios son los siguientes:

Acciones como CRUD (Create, Read, Update, Delete) son administradas mediante ORM.
La implementaci√≥n de seeds o semillas, nos permiten recuperar, mediante c√≥digo, la estructura de una BD.
.
Una de las bases te√≥ricas para entender este modelo es mediante el conocimiento de DAO (Data Access Object) y DTO (Data Transfer Object), los cuales nos permiten desestructurar un ORM en m√≥dulos de abstracci√≥n para acceder a la DB y transferir datos desde la misma DB, respectivamente hablando.
.
üôÉLos contras ser√≠an:

Delegaci√≥n de responsabilidades al server
Descentralizaci√≥n de trabajo, directa, de una BD.

## SEQUELIZE
* npm install --save sequelize
# Instalar segun la base de datos a utilizar:
* npm install --save pg pg-hstore
* npm install --save mysql2
* npm install --save sqlite3
* npm install --save tedious // MSSQL

## Caracteristicas de Sequelize
Sequelize gestiona la conexi√≥n con la base de datos. Una de las bases te√≥ricas para entender este modelo es mediante el conocimiento de DAO (Data Access Object) y DTO (Data Transfer Object), los cuales nos permiten desestructurar un ORM en m√≥dulos de abstracci√≥n para acceder a la DB y transferir datos desde la misma DB, respectivamente hablando.

## Instalaci√≥n y configuraci√≥n
Lo primero que estamos haciendo es importar la clase Sequelize despues lo que se hace es crear una nueva instancia de esta clase que recibe como par√°metros en su constructor, el nombre de la base de datos, el nombre del usuario, la contrase√±a, y un objeto de configuraci√≥n donde especificamos el host de nuestra base de datos, el dialect que es donde ponemos que base de datos se esta utilizando.

Sequelize permite utilizar consultas de forma directa con sql:

## Modelos

Los modelos en sequelize nos permiten representar nuestras tablas y manipular estos datos, un modelo se define de la siguiente manera:

https://ed.team/blog/agiliza-tu-desarrollo-en-nodejs-con-el-orm-sequelize
https://runebook.dev/es/docs/sequelize/manual/model-basics#:~:text=Un%20modelo%20es%20una%20abstracci%C3%B3n,y%20sus%20tipos%20de%20datos).


## Consultas
## Cambio de base de datos
## Migraciones








---
# VARIABLES DE AMBIENTE / ENTORNO
Las variables de entorno son variables dinamicas que afectan a el comportamiento de una aplicaci√≥n y son usadas cuando una aplicaci√≥n corre en diferentes entornos, por ejemplo, el de desarrollo o el de producci√≥n.

## USOS M√ÅS COMUNES:
1. Almacenar informaci√≥n sensible
2. Para aplicar configuraciones que sean espesificas para entornos de desarrollo
3. Para despliegue

Cuando se crean aplicaciones con Node JS del lado del back-end es muy usual conectarse a servicios de terceros, ejemplos:

* Bases de datos: Cuando se establece una conexi√≥n a una base de datos desde un back-end se debe ingresar la informaci√≥n necesaria para hacer de forma exitosa dicha conexi√≥n, informaci√≥n como el usuario de la base de datos, la contrase√±a, el host, el puerto entre otros.

* APIS de terceros: Estos servicios brindan un token y client_id que sirven para conectarse a estos servicios.

## Formas de crear las conexiones
> Tipeando de forma directa: Una forma de hacer estas conexiones es tipeando de forma explicita en el c√≥digo, en otras palabras quemando los datos, todos esos datos **LOS CUALES POR SUPUESTO SON MUY SENSIBLE** y por lo tanto es una **pesima** practica hacerlo de esta forma. Al publicar esto en un repositorio todo el mundo tiene acceso a esta informaci√≥n.

> Usando variables de entorno: Estas le a√±aden una capa de seguridad al c√≥digo dado que ya no muestra los datos de forma quemada.


## Uso de variables de entorno en Node JS

### Archivo .env y .env.example

### process.env:
process.env es un objeto **GLOBAL** que contiene como propiedades todas las variables de entorno

Se deben separar debido a que en el .env existe informaci√≥n sensible. Sin embargo, es necesario mostrar cuales son esas variables de etorno, por lo tanto, en el .env.example se ponen como un ejemplo de cuales son sin ponerlas de forma explicita.

Es un archivo que va contener todas las variables de entorno:
- Instalar el modulo dotenv
- Crear la carpeta config
- Crear el archivo .env
- Crear el archivo .env.example
- **No se debe subir el repositorio el .env**
- **Se pone en el repositorio el .env.example**
- Todas se escriben en UPPERCASE
- Si hay varias palabras se separan por _
- Creaci√≥n de de las variables de entorno
- Crear el script





## CON DOCKER
- Configurar docker con bases de datos
- Crear el archivo docker-compose.yml

### Comandos
- docker-compose up -d postgres
- docker-compose ps
- docker-compose down

## Explorando la base de datos del contenedor
Son formas de manipular la
### Con terminal
-docker-compose exec postgres bash: Terminal
-ls -l
-psql -h localhost -d my_store -U admin
- \d+
- \1

### Con motores graficos:


---


# AUTENTICACI√ìN Y AUTORIZACI√ìN || Authentication and authorization
Una de las tareas mas comunes del **backend** es hacer autenticaci√≥n y autorizaci√≥n ambos conceptos diferentes.

## Autenticacion:
Es la acci√≥n de validar quien es quien, de cara al sistema se valida que usuario esta en la app.

El sistema de autenticaci√≥n m√°s basico es el de: _email-password_,

### Passwords
Una contrase√±a debe exigirse (con ciertas matices) que tenga una buena seguridad.

En la base de datos la contrase√±a nunca debe ir en texto plano. **¬øPorque?** el hecho es que si se tiene acceso a la base de datos por alguna raz√≥n se puede suplantar la identidad de una persona y pueden ocurrir estragos.

Lo ideal es guardar las contrase√±as en otro formato para que la suplantaci√≥n sea lo mas dificil posible. Para realizar esta tarea se hace uso de un **Hash** que no es mas que un texto plano que se pasa por una funci√≥n y genera una clave llamada **criptografica**. Esa funcion tiene la facultad de que si no se vuelve aplicar el mismo texto plano sobre esa funcion, el hash jamas va a coincidir.

Ademas con el hash no se puede quitar el texto plano, es decir, _no se puede ir de hash a texto plano_. No hay forma de coger el hash y convertirlo a texto plano si no se tiene el texto plano (la clave correcta) sencillamente no se puede sacar el hash.

generalmente obtenemos el email y password desde el body usualmente en api rest.

Se compara contra la base de datos si coincide la informaci√≥n, falle el email o password, se retorna que no esta autenticado.

### Status codes
- 401 no autenticado - no authorized
- 403 no autorizado -  forbidden

## Autorizaci√≥n:
Se suele asociar a un rol, es decir llegado a cierto punto se suele chekear si se tiene un rol u otro. puies cada rol tendra acceso a ciertas cosas y otros no.


## SESI√ìN VS TOKEN:
Son dos de los mecanismos de autenticaci√≥n mas usados. No hay un estandar ni una unica forma de usarlos, se implementa uno u otro dependiendo de las necesidades del proyecto.

## AUTENTICACI√ìN POR SESI√ìN:
Un cliente hace una solicitud a un _Endpoint de login_.

Este *endpoint* de login le sirve al servidor (al menos por primera vez) para mostrarle que el cliente es quien dice ser.

El login es primer punto de autenticaci√≥n,  posteriormente para que no se tenga que estar enviando informaci√≥n de autenticaci√≥n (correo y clave) una y otra vez.... o en otras palabras para que el cliente se mantenga autenticado de cara al servidor por un periodo de tiempo razonable, el servidor intenta devolver algo para que el cliente pueda identificarse sin que este se mantenga enviando correo y clave constantemente. Ese algo es una **SESI√ìN**

**La sesi√≥n funciona as√≠:** El cliente se loggea y si todo es valido, el servidor genera un objeto que contiene cierta informaci√≥n a este objeto se le llama **sesion**.

Esta sesion tiene un identificador **unico**  y guarda esa informaci√≥n **(Este detalle es muy importante)** donde el desarrollador lo delegue, ya sea en una base de datos, en memoria etc.. A esta informaci√≥n se le ve agregando nueva informaci√≥n conforme el cliente vaya interactuando con el servidor.

## Stateful:
La autenticaci√≥n de tipo sesion es **stateful** dado que conforme el usuario va interactuando con mas endpoints, se va actualizando ese objeto sesion que esta en el servidor.

El servior habitualmente mete la sesion-id en una cabecera especial denominada **cookie**.

## Cookies
La cookie se guarda en el navegador.

Lo que va hacer esta cabecera **cookie** es que cuando el servidor la devuelva esta se setea en el navegador.

La cookie permite que cuando se haga una **solicitud** al dominio que creo esa cookie, se le envie esta de forma automatica. Ese comportamiento es nativo del navegador.

## Ejemplo:
Un cliente se loggea en un E-Commerce. En ese momento se crea la sesi√≥n, si el cliente pulsa en a√±adir un producto en esa solicitud el navegador metera en esa cabecera cookie el sesion id que le ha venido previamente. El servidor lo que hara consecuentemente es verificar si ese sesion id esta relacionado con la tabla de sesiones en la base de datos o donde sea que este guardado. Asi el servidor tiene constancia de quien esta autenticado y quien no y en que momento.

![]()

## AUTENTICACI√ìN POR TOKEN
Este mecanismo comienza igual, todo parte de una comunicaci√≥n cliente-servidor. La diferencia radica en como actua el servidor.

El servidor comprueba el email, la contrase√±a o lo que sea y genera un **TOKEN**. basado en el id del usuario y cierta informaci√≥n que se le quiera a√±adir a ese token y un **SECRETO** que solo conoce el **servidor**.

En base a ese secreto y a la informaci√≥n que se quiere guardar en el token se genera el mismo.

El token tiene informaci√≥n del usuario la sesion no.

El servidor devuelve el token en el body usualmente.

El navegador debe guardar este token en algun sitio, localstorage o como sea.

Cuando el navegador envia devuelta una solicitud mete en una cabecera llamada authorization ese token, el servidor toma el token y comprueba con el secreto que el sabe si ese token ha sido generado por el. Es como una huella, entonces el servidor compara ese token con el secreto para mirar que no haya ninguna anormalidad, no ha caducado ni ha sido alterado. Esto es clave porque aqui es servidor no guarda informaci√≥n de ningun tipo, por eso se denomina **Stateless**.

## Stateless
No se tiene un seguimiento de lo que va haciendo el usuario dado que no se tiene una sesi√≥n.

![](./)


# DIFERENCIAS
> En la sesi√≥n solo tenemos un id y ya || El token si puede tener informaci√≥n dentro desde el servidor

> La forma de enviarlo: La sesi√≥n si se usa el m√©todo de cookie entonces el envio al backend es automatico. El envio del token es manual por medio de la cabecera authorization.

> Validaci√≥n menos segura en sesi√≥n || El token es m√°s seguro por que tiene un secreto pero es muy peligroso implementarlo si no se sabe como funciona este a profundidad.




Here‚Äôs what we are looking for :
‚Ä¢ 5+ years of experience in Node.
‚Ä¢ Experience with SQL and NoSQL Databases.
‚Ä¢ Experience with Microservices and the Cloud.
‚Ä¢ Advanced algorithm knowledge.
‚Ä¢ IT infrastructure knowledge.
‚Ä¢ Intermediate agile methodologies management.
‚Ä¢ Strong understanding of best practices, SOLID principles, CLEAN Code, and scalable solutions.
‚Ä¢ Design Patterns knowledge.
‚Ä¢ Experience developing entire applications from scratch.
‚Ä¢ Experience in automated tests, and CI / CD pipelines.
‚Ä¢ Strong experience with Version control.
‚Ä¢ Advanced English level.




//* Para authsesion: Para cerrar sesion lo ideal es que en el servidor se elimine esa sesion tambien por lo cual se puede crear otro endpoit que reicba el mismo sesion id y lo elimine del array o la base de datos, y luego setear la cokie del navegadro a vacio o poner fecha de caducida de un segundo asi nos aseguramos que la sesion id no tenga relavancia ni el en el cliente ni el servidor

//* El token es bastante particular ya que debe cumplir con 3 requisitos minimamente.

// 1. Debe permitir meter dentro informaci√≥n, en este se va meter el id del usuaario de tal manera que el token sabe a que usuario  pertenece y a quien autentica.

// 2 Se debe poder definir la duraci√≥n de ese token, pasado ese tiempo ese token deja de ser valido.

// 3 Debe poder ser verificable, esto implica dos cosas, que no se pueda alterar y si se altera deje de ser valido  y que podamos ser capaces de verificar que fuimos nosotros los que los generamos. En ese sentido los tokens tienen una firma y cuando estos llegan al servidor nosotros comprobamos si nosotros hicimos esa firma.

// El jwt esta compuesto por tres partes. la uno es la cabecera indica el algoritmo y el tipo de token que vamos a genera, esta en base 64. Dentro de los tokens de tipo json hay algunos m√°s seria buena idea saber cuales son. Luego sigue la informaci√≥n que se ha introducido en el token habitualmente el id del usuario la fecha en la que fue creado el token y la caducidad, no es ideal poner informaci√≥n sensible aqui, es muy importante saber usarlos. La tercera parte es una firma que es una clave secreta si se altera el contenido la clave no coincidira, es un hash. El token cualquier persona lo puede leer porque es base 64 entonces de puede decodificar. Por lo tanto no guardar informaci√≥n personal del usuario en los tokens. Hay otros que van cifrados, es algo m√°s avanzado. JOSE es una libreria


// nano id es una libreria que genera identificadores

// El objeto res tiene el m√©todo Cookie permite devolver esa cabecera especial que se va setear en el navegador.

// Primero: nombre de la cookie
// Segundo: Es el valor como tal
// Tercero: parametro de opciones, tiene varias, las cuales se pueden ver en documentaci√≥n. Las m√°s relevantes son por ejemplo httpOnly para que la cookie no se pueda leeer desde js en el navegador, esto aporta cierta seguridad. / secure que permite que la cookie solo se envie por https sobre todo en producci√≥n / hay otras como el dominio, tiempo de expiracion,

//express necesita un middleware, se instala con npm i cookie-parser, cookieParser()para leer las cookies esto se establece en el expressApp

VALIDACIONES

Comprobar que la informaci√≥n que recibimos en algun punto tiene el formato o tipo correcto.

Ventajas
-Nos ahorramos ejecutar lineas de c√≥digo inncesarias

-Protege ciertas inseguridades

-Las validaciones pueden estar divividas segun las capas, es decir a medida que se adentrando entre capas pueden haber mas validaciones, por ejemplo se puede entrar a una capa de oruting y alli haber validaciones y si pasan pues se da acceso a otra capa que puede ser la de logica de negocios, y en esta tambien tener otras validaciones. En otras palabras se pueden tener varios puntos de validaci√≥n conforme la responnabilidades que tengsa cada capa de nuestro servidor.




DTO
Objeto que contiene informaci√≥n que se transfiere entre procesos.





QUE NECESITO PARA EL BACKEND

Tener un mecanismo que me permita





### PARA APRENDER
-Serie de videos de buenas practicas hacker nomada de node js
- Tareas en segundo plano para no sobrecargar el servidor
- Tareas en cola - Queu task
- Web kocks
- Documentar con swager
- Patrones de dise√±o (observador, mediador, inyecci√≥n de dependencias, factory, builder, singelton, estrategia, estado)


