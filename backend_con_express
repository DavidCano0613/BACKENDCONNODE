# CREACÍON DE UN BACKEND CON NODE JS
## PASOS PARA CREAR UN BACKEND
1. Elegir la arquitectura de software más adecuada para el caso.
2. Configurar del entorno de desarrollo y de producción con buenas practicas.
3. Instalar las librerias que seran necesarias para el desarrollo del proyecto.
4. Creación del servidor con EXPRESS.JS
5. Separar responsabilidades como lo indique la arquitectura elegida
6. Crear la capa de routing.
7. Crear la capa de middlewares.
8. Crear la capa de servicios.
9. Crear la capa de librerias y establecer la conexión con bases de datos.
10. Crear la capa de seguridad, establecer todo lo relacionado con autenticación y autorización.
11. Crear y correr de pruebas.
12. Hacer deploy.
---

# 1) The Clean Architecture.
Es un estilo de arquitectura de software que funciona separando el software en capas.

> La capa mas pequeña es la de entidades en esta capa es donde se definen las entidades base del negocio en este proyecto por ejemplo, usuarios, productos, ordenes de compra, categorias etc...

> Luego se tiene una capa de casos de uso, aqui normalmente se tiene todo lo relacionado a la lógica de negocio y se ven los servicios en esta capa.

> Luego estan los controladores que son los que brindan acceso a estos servicios, aquí se ve el routing y los middlewares que ayudan a capturar errores y a hacer validaciones.

Imagen:
![](./assets/theclena.png)

De una forma más transparente:
![](./assets/Captura%20de%20pantalla%202022-07-31%20140441.png)

> Finalmente esta la capa de los clientes que seran todos los dispositivos conectados a esa API.

> Resumen del flujo: Los clientes se conectan con los controladores, estos a su vez se conectan con los servicios y los servicios se encargan de conectarse con las bases de datos o su respectiva fuente de información y realizar una lógica de negocio.

![](./assets/Captura%20de%20pantalla%202022-07-31%20170216.png)


---
# 2) Configuración de entorno de etorno de desarrollo y de producción con buenas practicas:

Establecer una buena configuración servira para trabajar de una forma más apropiada.

- Crear un buen **git ignore:** Este se coloca en el directorio raiz del proyecto:  https://www.toptal.com/developers/gitignore.
- Configuración del editor de código: Es recomendable para que todos los desarrolladores tengan la misma configuración en su editor de código. **Tener la extensión editorconfig**. Se puede establecer una configuración que lo que haga sea formatear el editor de código para que todos trabajen de la misma manera.
- Nodemon como servidor de desarrollo: Creaación algunas tareas o scripts en el package json.
- Linters: Eslint
- Pipelines:

### Instalación de paquetes:
npm i nodemon eslint eslint-config-prettier eslint-plugin-prettier prettier -D

---
# Instalación de la librerias que seran necesarias para el desarrollo

A continuación se presenta un paquete de librerias que pueden ser utiles para crear backend con node js:

1. Express: npm i express

2. Eslint:

3. nanoid

4.

2. Boom: npm i @hapi/boom

3. Joi:
npm install --save joi
npm install --save-dev @types/joi

4. Postgres:
* npm install --save pg pg-hstore
* npm install --save mysql2
* npm install --save sqlite3
* npm install --save tedious // MSSQL

5. Cors: npm i cors

6. sequelize:
* npm install --save sequelize
* npm i sequelize-cli -D: Para migraciones
*

npm i dotenv

---
# Creación del servidor con express JS

EXPRESS: Es una libreria que permite gestionar de una mejor manera un servidor web.

La instacia de express trae en forma de función los métodos/verbos http.
**get post put patch y delete**.

A estas funciones se les puede pasar los paths (_URLS,Endpoints_) que no son más que un punto final en el servidor donde se aloja un recurso. Los clientes van a solicitar recursos a esas URLS con los verbos http y va haber un handler que se ejecuta cuando la ruta coincide. Esto se puede entender de la siguiente forma:

>El método http recibe dos parametros la URL y una función de tipo callback llamada handler que ejecuta cierta lógica de programación CUANDO se ataque a ese EAndpoint. El callback recibe dos objetos que son *REQUEST AND RESPONSE*.

Los objetos **request y response** son muy importante puesto que por medio de estos es que se recibe y envia la información.

Express permite trabajar con el REQUEST.BODY de una forma más amigable.
Express contiene algo llamado *parser* el cual es un middleware que ayuda a tomar el body que viene en forma de un stream y _parsearlo_ a algun tipo de dato, ya sea un archivo de texto, un json o lo que sea. Lo más usual es parsearlo a JSON. Este se puede establecer en el index de forma global para que a todos los endpoints les llegue el body parseado.

---
# Separación de responsabilidades (Single Responsability Principle)

Hace parte de los principios SOLID. En este caso *Single Responsability Principle* establece que es una mala practica tener código que hace de todo, es decir si una función tiene como nombre sumar, no debería en su cuerpo estar calculando integrales. Esto se puede llevar al plano de los archivos, routing, clases, modulos, servicios y más. Es aqui donde se lleva realmente acabo la arquitectura.

---
# Creación de la capa de routing y controladores

* Como se menciono the clean architecture establece que el routing hace parte **de la capa de acceso a los servicios** y también se encarga de proporcionar los EndPoints a los cuales los clientes se van a conectar para acceder a los recursos. Sin embargo, es una pesima practica definir todo el routing en el archivo index donde se levanta el servidor.
* Express cuenta con sistema de enrrutamiento el cual permite separar las rutas.
* Los Routers en express son middlewares que permiten agrupar rutas para así separar la lógica de los endpoints.
* Todo el routing deberia dividirse en archivos que se encarguen de definir las rutas de cada endpoint en espesifico.
* Lo ideal es crear una carpeta que contenga todo el routing.
* El nombre que se le dan a estos archivos dependen del equipo de desarrollo.
* Se debe definir un path principal para ese router, es decir debe tener como su entorno propio.
---
# Creación de los middlewares

## Que son los middlewares y para que sirven
Como se ha observado anteriormente en los Endpoints se establece cierta lógica. Pero ¿que tal si se necesita ejecutar una función antes de que se ejecute la lógica del endpoint, como por ejemplo, validar permisos o validar que la data venga como se espera?

Los middlewares sirven para eso, pues son FUNCIONES que se ejecutan de **FORMA PREVIA** a los handlers de los endpoints, es muy importante hacer esta notación y es que antes de que la petición llegue al endpoint y se ejecute la lógica que tiene el handler asociado a este, se ejecuta primero el middleware que esta definido en esa ruta.

## Sintaxis
> Se crea una función normal con la logica que va contener ese middleware, luego ya sea a nivel de toda la app o de un grupo de endpoints espesificos se llama al método USE.

> Express dispone del **método use()** el cual recibe como parametro el **request y el response** y un método muy importante llamado **next** el cual se explica despues de las propidades de los middlewares. Entonces en ese orden de ideas los middlewares se crean asi:
- algo.use()

## Propiedades de los middlewares en express JS

1. **El orden es importante:** Los middlewares se ejecutan en el mismo orden que se llamen en el código

2. **Pueden ser utilizados de forma global:** Ejemplo: para capturar errores a nivel general en toda la aplicación, en este caso pueden ponerse en el index de la app.

3. **Pueden ser utilizados a nivel de cada endpoint o de un grupo de endpoints:** De esta forma el middleware una vez se ejecuta, llama al handler del endpoint al que se haya atacado. Esto también lo hace next()

4. **Funcionan de forma secuencial** Una de sus propiedades es que pueden funcionar de forma secuencial. Cada middleware puede tener una función  espesifica, una vez termine... sigue el otro middleware con otra lógica diferente. Es como tener funciones tradicionales conectadas en cadena, se ejecuta una y le pasa el flujo a la siguiente y asi sucesivamente. Un middleware puede bloquear el flujo, Es decir si cierta lógica no se cumple no se permite seguir con el siguiente middleware o no permite acceder a la siguiente capa, esto viene muy bien a la hora de hacer validaciones.

5. **El dichoso método Next():** El método NEXT (que también viene como parámetro en el use()) es un callback que permite que el siga el proximo middleware o en su defecto el handler que tenga el endpoint. **(Hay un dilema y es que express no diferencia muy bien entre middlewares y rutas, practicamente las funciones (handlers) que se ejecutan en las rutas son middlewares también)**.
## Uses Cases
- Funcionan como pipes
- Validan datos
- Capturan errores
- Validan permisos
- Controlan accesos

## Middleware de tipo error.
Es ideal que antes de que la petición llegue al endpoint se capturen los posibles errores. Sin embargo, estos no deben devolverse a secas. Los errores hay que gestionarlos, darles un formato y mandarlos de una forma clara y bien presentada al cliente.

### Sintaxis middleware de error
Tienen el parámetro error de primero **(error,req,res,next).**

Son utiles para crear un middleware GLOBAL (funcionan a nivel de todos los endpoints) que acompañe a todas las peticiones de tal manera de que si sale un error este se capture y se le de un formato para retornalo, **¿que formato?** ejemplo: _el tipo de error, el codigo de estado y un mensaje._.

Este tipo de middlewares se deben crear despues de hacer todo el Routing.
Este tipo de middlewares se crean en un carpeta y se llaman donde se requiran y se ponen también en el routing.

## Libreria Boom
Esta libreria ayuda a gestionar de forma más eficiente lo errores. Pues hasta el momento se ha enviado el status code, message, entre otros de forma que siempre se debe poner el status code manualmente. Boom ayuda a ahorrar esta molestia.

isBoom: Si es un error de tipo boom
output: Toda la informacion del error

#### Ventajas de usar Boom:
- Ayuda a no tener que poner el status code de forma manual
- Gestiona mejor los errores


## Middleware de tipo validación
Otro uso muy común de los middlewares es validar los datos que vienen desde el cliente (front-end). Para esto existe una librería llamada Joi.

Como backend un desarrollador debería asgurarse de que lo que le envia el front-end cumple con la integridad de datos, que un precio este un formato adecuado o por ejemplo que se envien los atributos que se esperan, con los middlewares se pueden capturar este tipo de errores antes de que lleguen a la capa de servicios.


---
# Creación de la capa de servicios

Es la capa donde se pone la lógica del negocio como tal. Esta capa encapsula todos los casos de uso.

Los servicios tienen la lógica del negocio y obtienen información por medio de librerias a una base de datos o de una api externa. Luego estos servicios pueden sen consumidos por los controladores. Practicamente en esta capa se centraliza la lógica de la aplicación. Pero esta capa es accedida una vez se ha cumplido con todo lo que los controladores y middlewares tienen que hacer, ya sea: Capturar errores, hacer validaciones, verificar autenticación y autorización.
---
# VARIABLES DE AMBIENTE / ENTORNO
Tener archivos de configuraciones separados en diferentes ambientes es una buena practica. Cuando una aplicación web se va a a desplegar se esta hablando de que una aplicación se va usar al menos en dos ambientes diferentes. _Producción y desarrollo_.

En las empresas grandes existen más entornos.

Para cuyos casos es necesario para cada entorno crear sus respectivos archivos de configuración.

Las variables de entorno son variables dinamicas que afectan a el comportamiento de una aplicación y son usadas cuando una aplicación corre en diferentes entornos, por ejemplo, el de desarrollo o el de producción.

## USOS MÁS COMUNES:
1. Almacenar información sensible.
2. Para aplicar configuraciones que sean espesificas para entornos de desarrollo.
3. Para despliegue.

### Cuando se crean aplicaciones con Node JS del lado del back-end es muy usual conectarse a servicios de terceros, ejemplos:

* Bases de datos: Cuando se establece una conexión a una base de datos desde un back-end se debe ingresar la información necesaria para hacer de forma exitosa dicha conexión, información como el usuario de la base de datos, la contraseña, el host, el puerto entre otros.

* APIS de terceros: Estos servicios brindan un token y client_id que sirven para conectarse a estos servicios.

## Formas de crear las conexiones con bases de datos.
> Tipeando de forma directa: Una forma de hacer estas conexiones es tipeando de forma explicita en el código, en otras palabras quemando los datos, todos esos datos LOS CUALES POR SUPUESTO **SON MUY SENSIBLES** y por lo tanto es una **pesima** practica hacerlo de esta forma. Al publicar esto en un repositorio todo el mundo tiene acceso a esa información y podran acceder a la base de datos.

> Usando variables de entorno: Estas le añaden una capa de seguridad al código dado que ya no muestra los datos de forma quemada.

## Uso de variables de entorno en Node JS

### Objeto process.env:
process.env es un objeto **GLOBAL** que contiene como propiedades todas las variables de entorno.

Se puede crear un objeto config que contenga todas las variables de etorno. Una practica que suele seguirse es protegerlas un poco y guardar todas estas variables de entorno en una URL con todo el esquema de conexión.

Para acceder al archivo .env y cargar las variables a un proceso de node, se debe instalar un paquete para poder acceder a estas y se llama al método config.

Es un archivo que va contener todas las variables de entorno:
- Instalar el modulo dotenv
- Crear la carpeta config
- Crear el archivo .env
- Crear el archivo .env.example
- **No se debe subir el repositorio el .env**
- **Se pone en el repositorio el .env.example**
- Todas se escriben en UPPERCASE
- Si hay varias palabras se separan por _
- Creación de de las variables de entorno
- Crear el script

### Archivo .env y .env.example
Se deben separar debido a que en el .env existe información sensible. Sin embargo, es necesario mostrar cuales son esas variables de etorno, por lo tanto, en el .env.example se ponen como un ejemplo de cuales son sin ponerlas de forma explicita.

---
# CAPA DE librerias
Estan se encargan de todo lo que tiene que ver con conexión con terceros, es en esta carpeta donde se crean todos los archivos que se encargan de conectar a la back-end con terceros como **Bases de datos** y **APIS**

# CONEXIÓN A BASE DE DATOS
Existen diversas formas de conectar el **Backend** con **bases de datos**.

1. La más común, por lo menos para empezar a entender el como gestionar información de una base de datos desde el backend es descargando un SGDB y buscando la libreria que permita conectar a Node js con dicho motor. Sin embargo, la forma recomendada es con un pooling.

> Conexión con POSTGRESQL: Para conectar Node JS con una base de datos pg: https://node-postgres.com/
> Conexión con MYSQL: Para conectar Node JS con una base de datos mysql: https://node-postgres.com/
> Conexión con SQLSERVER: Para conectar Node JS con una base de datos sqlserver: https://node-postgres.com/

## Pooling
Cuando se trabaja con bases de datos en el backend, cada vez que se hace una operación contra la misma, primero se debe generar una conexión con la base de datos.

Por lo que tener que llamar al método que conecta la base de datos con el backend por cada vez que se quiere hacer una operación se vuelve muy tedioso. Ademas, eso esta mal porque puede sobrecargar el servidor de request. Entonces, esto es un problema porque por cada request se crea una negociacion con la base de datos, se tarda 20ms o mas, y asi se va saturando el servidor. Por lo tanto el SGDB proporcionan una interfaz llamada pool.

Un pool de conexiones basicamente es un conjunto limitado de conexiones a una base de datos, que es manejado por un servidor de aplicaciones de forma tal, que dichas conexiones pueden ser reutilizadas por los diferentes usuarios.

Es como un lugar en el que se centralizan estas conexiones para no tenerlas que estar llamando cada vez, si no desde el pool. Lo que hace el pool es sencillamente es ser un mediador entre las bases de datos y el cliente.

Entonces a medida que los clientes empiecen a hacer consultas, la aplicacion de manera asincrona se conectara con el pool y el pool se encargara tanto de abrir o cerrar conexiones para que la informacion siga trabajando de manera eficiente.

![](./assets/OOFTe.png)


---
# ORM: Object-Relational mapping
Un ORM es un modelo de programación es una capa que permite mapear las estructuras de una base de datos relacional en entidades de la programación orientada a objetos. Es decir, el ORM toma las tablas y las convierte en POO basicamente. Es como usar programación orientada a objetos para hacer operaciones contra la base de datos. El ORM es agnostico, pues este se puede usar en cualquier SGDB.

Al abstraer este tipo de programación, se delega su implementación al Backend, es decir, le añadimos una de responsabilidad a la capa transaccional del servidor:

✨Los beneficios son los siguientes:

Acciones como CRUD (Create, Read, Update, Delete) son administradas mediante ORM.
La implementación de seeds o semillas, nos permiten recuperar, mediante código, la estructura de una BD.

## EL DAO Y DTO
Una de las bases teóricas para entender este modelo es mediante el conocimiento del DAO (Data Access Object) y DTO (Data Transfer Object), los cuales nos permiten desestructurar un ORM en módulos de abstracción para **acceder a la DB** y **transferir datos desde la misma DB**, respectivamente hablando.

🙃Los contras serían:
- Delegación de responsabilidades al server.
- Descentralización de trabajo, directa, de una Data Base.

## SEQUELIZE
* npm install --save sequelize
## Instalar segun la base de datos a utilizar:
* npm install --save pg pg-hstore
* npm install --save mysql2
* npm install --save sqlite3
* npm install --save tedious / MSSQL

## Caracteristicas de Sequelize
Sequelize gestiona la conexión con la base de datos.

## Instalación y configuración
Lo primero que estamos haciendo es importar la clase Sequelize despues lo que se hace es crear una nueva instancia de esta clase que recibe como parámetros en su constructor, el nombre de la base de datos, el nombre del usuario, la contraseña, y un objeto de configuración donde especificamos el host de nuestra base de datos, el dialect que es donde ponemos que base de datos se esta utilizando.

Sequelize permite utilizar consultas de forma directa con sql:

## Modelos en sequelize

Los modelos en sequelize nos permiten representar las tablas y manipular estos datos, un modelo se define de la siguiente manera:

Usando la clase class model Extends Model.
Usando el método sequelize.define()
Consultar los tipos de datos y configuraciones de columnas que admite sequelize.
Por defecto el nombre que se le de al modelo se crea en la base de datos
Se puede crear explicitamente el nombre de la tabla aunque el modelo tenga otro nombre

### Create Update and Delete
### Sincronización de Modelos.

Aquí es donde entra en juego la sincronización de modelos. Un modelo se puede sincronizar con la base de datos llamando a model.sync(options), una función asíncrona (que devuelve una Promesa). Con esta llamada, Sequelize realizará automáticamente una consulta SQL a la base de datos. Tenga en cuenta que esto cambia solo la tabla en la base de datos, no el modelo en el lado de JavaScript.

>User.sync()- Esto crea la tabla si no existe (y no hace nada si ya existe)
>User.sync({ force: true })- Esto crea la tabla, borrandola primero si ya existía
>User.sync({ alter: true })- Esto verifica cuál es el estado actual de la tabla en la base de datos (qué columnas tiene, cuáles son sus tipos de datos, etc.), y luego realiza los cambios necesarios en la tabla para que coincida con el modelo.

>Se puede hacer a nivel de un solo modelo Model.sync()

>Se puede hacer a nivel generl todos los modelos existentes sequelize.sync

## Consultas
Para hacer consultas con Sequelize
Se puede mapear con POO o se le puede mandar una consulta directa tipo SQL, la información la devuelve en un array, con dos posiciones la primera es la data como tal y la otra es meta data que viene a ser como informacíon adicional de la consulta.

## Cambio de base de datos

## Migraciones
Cuando una aplicación esta en producción esta el dilema de como se sincroniza la base de datos con lo que se va haciendo en local ?

El problema de sequelize.sync() es que empieza a leer los modelos, crea tablas y hace relist (se sobrescribe información), no se aconseja que se corra esto así en producción. Es mejor sincronizar con un sistema de migraciones.

Las migraciones son como un sistema de control de versiones para bases de datos.

Mantienen un hisotrial del esquema que se va manteniendo en la base de datos.

Usualmente se va tener una primer migracicón que es la que crea toda la estructura inicial y todas las tabals como lass columnas con sus respectivos tipos de datos. Luego a medida que se van añadiendo campos o haciendo alguna modificacion deberiamos tener esto en un sistema de migraciones, ¿Porque? esto es debido a que cuando un sistema esta corriendo en producción, se debe replicar todo y con las migraciones se pueden enviar nuevos **releases**. El sistema en producción debe saber en que momento de la migración para que no se rescriban datos ni repita información.

Nuevamente la función sync crea nuevamente tablas y demás lo cual es muy peligroso para
cuando el sistema esta en producción dado que se puede sobrecargar al estar creando tablas una y otra vez cuando se lanza un nuevo feature, e incluso puede haber pedida de información.

La migración corre o toma como punto de referencia la ultima que se haya corrido.

## ¿COMO CREAR MIGRACIONES EN SEQUELIZE?

Se instala npm i sequelize-cli -D

>Agregar un archivo de configuración en la carpeta raiz llamado -sequelizerc

>Las migraciones van a tener su propia conexíon independiente a la que ya tiene la aplicación

>Se deben declarar los ambientes de development y production

> A diferencia de laravel que trae los comandos de terminal por defecto, en sequelize debemos crearlos y la forma de hacerlo es creando scripts de NPM.

## Seeders
### UP:
### DOWN:
### Comandos de migraciones

* sequelize-cli db:migrate: Run pending migrations.
* sequelize-cli db:migrate:schema: timestamps:add Update migration table to have timestamps.
* sequelize-cli db:migrate:schema: timestamps:add Update migration table to have timestamps
* sequelize-cli db:migrate:status: List the status of all migrations
* sequelize-cli db:migrate:undo: Reverts a migration
* sequelize-cli db:migrate:undo: all Revert all migrations ran

* sequelize-cli db:seed: Run specified seeder
* sequelize-cli db:seed:undo: Deletes data from the database
* sequelize-cli db:seed:all: Run every seeder
* sequelize-cli db:seed:undo:all: Deletes data from the database

* sequelize-cli db:create Create database specified by configuration
* sequelize-cli db:drop Drop database specified by configuration
* sequelize-cli init Initializes project
* sequelize-cli init:config Initializes configuration
* sequelize-cli init:migrations Initializes migrations
* sequelize-cli init:models Initializes models
* sequelize-cli init:seeders Initializes seeders
* sequelize-cli migration:generate Generates a new migration file
[aliases: migration:create]
* sequelize-cli model:generate Generates a model and its migration
[aliases: model:create]
* sequelize-cli seed: generate Generates a new seed file.
* generate create-user
---

Cuando se corre el comanndo run esot genera una tabla llamada SequelizeMeta esta tabla es clave, esto es lo que se permite que se haga el tracking (historico) de la migración, es como un registro o historial por lo cual si se vuelve a correr la migración ya no va a rescirbir información porque ya tiene registro de que esa migración se hizo eso permite tener un orden a la hora de mandar cambios a producción

Para hacer modificaciones a tablas ya creadas se tiene que ir al modelo se hace el camibio pertinente y se informa de esto a la migración.


## Relaciones en sequelize

One to one relation
One to many
Many to Many


https://pigexception.wordpress.com/2016/03/26/patron-de-diseno-dao/


---
# Considereaciones para hacer deploy

1. Evaluar los Cors
2. Que la api este en un servidor https
3. Correr todos los procesos de build (typescript o sass por ejemplo)
4. Remover todos los console.log
5. Seguridad (helmet)
6. Testing

# CORS
Uno de los problemas más comunes es el problema de cors, es un problema muy común a la hora de conectar el **Back-end con el Front-end**.

### Cross.Origin Resource Sharing
Significa que los servidores tienen una protección por defecto y es que solo aceptan peticiones desde su mismo origen.

Si las peticiones salen desde el mismo origen (localhost) el Backend acepta la petición, pero cuando se tienen diferentes origenes (clientes, un front o un movil).

Insomnia o postamn y este tipo de herramientas nos abstraen de ver este error porque por debajo usan un proxy que cambia el origen.

### Las formas de resolver el problema es la siguiente:

# Deploy con heroku
npm i -g heroku
heroku --version
heroku login
heroku create
git remote -v
  "engines":{
    "node": "14.x"
  }
Heroku local web
https://git.heroku.com/peaceful-headland-45148.git







### PARA APRENDER
-Serie de videos de buenas practicas hacker nomada de node js
- Tareas en segundo plano para no sobrecargar el servidor
- Tareas en cola - Queu task
- Web kocks
- Documentar con swager
- Patrones de diseño (observador, mediador, inyección de dependencias, factory, builder, singelton, estrategia, estado)


